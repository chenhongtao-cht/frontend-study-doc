## 2023 年 7 月 10 日

回流(Reflow)、重绘(Repaint) 和 BFC(Block Formatting Context)
## 一. 浏览器的渲染过程

本文先从浏览器的渲染过程来从头到尾的讲解一下回流重绘，如果大家想直接看如何减少回流和重绘，优化性能，可以跳到后面。（这个渲染过程来自MDN）
![渲染过程](/images/days/lianlanqixuanran.jpg)

从上面这个图上，我们可以看到，浏览器渲染过程如下：

1. 解析HTML，生成DOM树，解析CSS，生成CSSOM树
2. 将DOM树和CSSOM树结合，生成渲染树(Render Tree)
3. Layout(回流):根据生成的渲染树，进行回流(Layout)，得到节点的几何信息（位置，大小）
4. Painting(重绘):根据渲染树以及回流得到的几何信息，得到节点的绝对像素
5. Display:将像素发送给GPU，展示在页面上。（这一步其实还有很多内容，比如会在GPU将多个合成层合并为同一个层，并展示在页面中

渲染过程看起来很简单，让我们来具体了解下每一步具体做了什么。
生成渲染树
![生成渲染树](/images/days/shengcehengshu.jpg)

为了构建渲染树，浏览器主要完成了以下工作：

1. 从DOM树的根节点开始遍历每个可见节点。
2. 对于每个可见的节点，找到CSSOM树中对应的规则，并应用它们。
3. 根据每个可见节点以及其对应的样式，组合生成渲染树。

第一步中，既然说到了要遍历可见的节点，那么我们得先知道，什么节点是不可见的。不可见的节点包括：

一些不会渲染输出的节点，比如script、meta、link等。
一些通过css进行隐藏的节点。比如display:none。注意，利用visibility和opacity隐藏的节点，还是会显示在渲染树上的。只有display:none的节点才不会显示在渲染树上。

从上面的例子来讲，我们可以看到span标签的样式有一个display:none，因此，它最终并没有在渲染树上。


## 二. 回流(Reflow) 
#### 1.1 概念
回流也叫重排，当元素的布局属性发生变化，导致了整个文档的布局结构发生改变时，浏览器会进行回流。回流会使浏览器重新计算元素的几何属性（位置和尺寸），并重新构建页面的布局树。回流是一种较为昂贵的操作，因为它会涉及到多个元素和整个文档的重新计算和布局。

#### 1.2. 回流触发时机

+ 页面初始渲染，这是开销最大的一次回流，并且避免不了；
+ 添加或删除可见的 DOM 元素；
+ 元素的位置发生变化；
+ 元素的尺寸发生变化（包括外边距、内边距、边框大小、高度和宽度等）；
+ 元素内容发生变化（例如文字数量、字体、图片大小等）；
+ 元素字体大小改变；
+ 改变浏览器窗口尺寸（例如 resize 事件发生时）；
+ 激活 CSS 伪类（例如 :hover）；
+ 设置 style 属性的值，因为通过设置 style 属性改变节点样式的话，每一次设置都会触发一次回流；
+ 查询某些属性或调用某些计算方法：offsetWidth、offsetHeight 等，除此之外，当我们调用 getComputedStyle 方法，或者 IE 里的 currentStyle 时，也会触发回流，原理是一样的，都为求一个 “即时性” 和 “准确性” 。


## 三. 重绘(Repaint)

#### 2.1. 概念
当元素样式的改变导致了元素的可见外观发生变化，但并未影响其布局时，浏览器会进行重绘。重绘是一个比较轻量级的操作，不会影响整个文档的布局，只会重新绘制受影响的部分。

#### 2.2. 重绘触发时机

+ 可见性(visibility)和透明度(opacity)的改变；
+ 颜色的改变；
+ 背景的改变；
+ 阴影、轮廓的改变；
+ 文本方向(text-decoration)的改变等。

## 四. 如何尽量避免回流重绘

#### 3.1 浏览器对于回流和重绘的优化

+ 浏览器会维护一个队列，把所有会引起回流、重绘的操作放入这个队列，等队列中的操作到了一定数量或者到了一定的时间间隔，浏览器就会 flush 队列，进行一个批处理。这样就会让多次的回流、重绘变成一次回流重绘。

+ 但当你获取布局信息的操作的时候，例如 offsetTop 等，为了保证获取结果的准确性，就会打破浏览器的这种优化策略，强制浏览器提前 flush 队列。


#### 3.2 css 中避免回流和重绘

+ 减少回流范围，尽量将需要回流的内容固定在局部范围。
+ 不要使用 table 布局，可能很小的一个改动会造成整个 table 的重新布局。不得已使用 table 的场景，可以设置 table-layout: auto; 或者 table-layout: fixed; 这样可以让 table 一行一行的渲染，同时可可以限制回流的影响范围。
+ 集中修改样式。这样可以尽可能利用浏览器的优化机制，一次回流重绘就完成渲染。
+ 避免设置多项内联样式。
+ 如果想设定元素的样式，可以通过改变元素的 class 类名（尽可能在 DOM 树的最里层）。
+ 将 DOM 离线。通过设置元素属性 display: none; 将其从页面上去掉，然后再进行后续操作，这些后续操作将不会出发回流、重绘，最后通过 display 属性显示。另外，visibility: hidden 的元素只对重绘有影响，不影响回流。
+ 使用 position: absolute / fixed; 脱离文档流。例如那些复杂的动画，对其设置 position: absolute / fixed; 尽可能地使元素脱离文档流，从而减少对其他元素的影响。
+ 利用 transform translate 去代替 left top 的变换。
+ 使用 css3 硬件加速，可以让 transform、opacity、filters 这些动画不会引起回流重绘。
+ 避免使用 css 的 JavaScript 表达式。
+ 将频繁回流或重绘的节点设置为图层。将节点设置为 video 或 iframe；为节点添加 will-change 属性。


#### 3.3 js 中避免回流和重绘

+  减少直接操作 `DOM` 元素。不要一条一条地修改 `DOM` 的样式，改用 `className` 来控制。

+  分离读写操作。当需要 js 操作元素样式时，即将获取样式属性的操作集中执行，并缓存值，在需要设置样式属性时也集中处理，避免获取和设置的操作互相夹杂。因为获取、设置的操作都会引起回流。

+  动态插入多个节点时，可以使用文档碎片（DocumnetFragment），创建后一次插入，避免多次的渲染性能。DocumnetFragment 是一个保存多个元素的容器对象（保存在内存），当更新其中的一个或者多个元素时，页面不会更新。

+  不要把 `DOM` 节点的 offsetLeft 等属性值放在一个循环里当成循环里的变量。

5. 使用 resize 事件时，做防抖和节流处理。


## 五. BFC(Block Formatting Context)
#### 4.1 概念
是CSS中的一个重要概念，它是一种页面中的渲染区域，用于控制块级元素的布局和渲染行为。BFC在页面中创建一个独立的环境，其中的元素按照一定的规则进行布局，并具有一些特殊的渲染行为

#### 4.2 作用
BFC的主要作用是解决元素在布局过程中的浮动、清除浮动、外边距折叠等问题，同时还可以阻止元素之间的重叠。

#### 4.3 触发BFC的条件

+ 根元素（`<html>`）
+ 浮动元素（float不为none）
+ 绝对定位元素（position为absolute或fixed）
+ display为inline-block、table-cell、table-caption、flex、grid等
+ overflow不为visible的元素

#### 4.4 BFC的常见应用场景
+ 清除浮动：将父元素触发BFC，可以清除其内部浮动元素的影响，使父元素包裹浮动元素。
+ 阻止外边距折叠：在BFC中，两个相邻块级元素的外边距不会折叠，从而保持正确的间距。
+ 创建自适应的两栏布局：通过触发BFC，可以避免浮动布局的一些问题，实现更稳定的布局效果。
