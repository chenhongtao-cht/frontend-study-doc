---
layout: doc
---

## 2024 年 7 月 25 日

## 1.如果你要读取一个特别大的文件应该如何做?
使用`fs.createReadStream`代替`fs.readFileSync`

[参考地址](https://segmentfault.com/a/1190000045090539)
[参考地址](https://segmentfault.com/a/1190000041489765)

## 2. 防抖和节流

```js
// 防抖：就是指触发事件后 n 秒后才执行函数，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。
function debounce(func, wait) {
    let timer = null;
    return function() {
        const context = this;
        const args = [...arguments];
        if(timer) {
            clearTimeout(timer);
        }
        timer = setTimeout(() => {
            func.apply(context, args);
        }, wait)
    }
}

// 立即执行
function debounce(func, wait, immediate = false) {
    let timer = null;
    return function() {
        const context = this;
        const args = [...arguments];
        if(timer) {
            clearTimeout(timer);
        }
        if(immediate) {
            const callNow = !timer;
            timer = setTimeout(() => {
                timer = null;
            }, wait);
            if(callNow) func.apply(context, args);
        } else {
            timer = setTimeout(() => {
                func.apply(context, args);
            }, wait)
        }
    }
}

// 节流:就是指连续触发事件但是在 n 秒中只执行一次函数。
function throttle(func, wait) {
    let timer = null;
    return function() {
        const context = this;
        let args = [...arguments];
        if(!timer) {
            timer = setTimeout(() => {
                timer = null;
                func.apply(context, args);
            }, wait)
        }
    }
}

```

## 3. 千分位格式化

```js
// 先判断正负和小数部分
function formatThousandth(number) {
    let isNeg = false;
    let isDecimal = false;
    let interArr = [];
    let decimalArr = [];
    if(number < 0) {
        isNeg = true;
        number = Math.abs(number)
    }
    number = number.toString();
    if(number.indexOf('.') > -1) {
        isDecimal = true;
    }
    interArr = [...number.split('.')[0]];
    decimalArr = number.split('.')[1];
    let flag = 1;
    let len = interArr.length;
    for(let i = len - 1; i >= 0; i--) {
        if(flag % 3 === 0 && i !== 0) {
            interArr.splice(i, 0, ',');
        }
        flag++;
    }
    if(isDecimal) {
        interArr.push('.');
        interArr.push(decimalArr);
    }
    return (isNeg ? '-' : '') + interArr.join('')
}
```

## 4.前k个最大值
```js
// 方法1：排序
function findKthLargest(nums, k) {
    nums.sort((a, b) => b - a);
    return nums[k - 1];
}

// 方法二： 部分冒泡

function findKthLargest(nums, k) {
    for(let i = 0; i < k; i++) {
        for(let j = 0; j < nums.length - 1 - i; j++) {
            if(nums[j] > nums[j + 1]) {
                [nums[j], nums[j + 1]]=[nums[j + 1], nums[j]]
            }
        }
    }
    return nums[nums.length - k];
}

// 方法三： 小顶堆

function findKthLargest(nums, k) {
    // 初始化小顶堆
    let minHeap = new MinHeap();
    // 前k个元素入堆
    for(let i = 0; i < k; i++) {
        minHeap.push(nums[i]);
    }
    // 从k + 1个元素开始 如果当前元素大于对顶元素 则 删除堆顶元素，在添加该元素
    for(let i = k; i < nums.length; i++) {
        if(nums[i] > minHeap.top()){
            minHeap.push(nums[i]);
            if(minHeap.size() > k) {
                minHeap.pop();
            }
        }
    }
    return minHeap.top();
}

class MinHeap {
    constructor() {
        this.heap = [];
    }

    getParentIndex(i) {
        // return i - 1 >> 1;
        return Math.floor((i - 1) / 2);
    }

    getLeftIndex(i) {
        return 2 * i + 1;
    }

    getRightIndex(i) {
        return 2 * i + 2;
    }

    top() {
        return this.heap[0];
    }

    swap(i1, i2) {
        const temp = this.heap[i1];
        this.heap[i1] = this.heap[i2];
        this.heap[i2] = temp;
    }

    size() {
        return this.heap.length;
    }

    push(val) {
        this.heap.push(val);
        this.shifUp(this.heap.length - 1);
    }

    // 上移
    shifUp(index) {
        if (index === 0) return;
        const parentIndex = this.getParentIndex(index);
        if(this.heap[parentIndex] > this.heap[index]) {
            this.swap(parentIndex, index);
            this.shifUp(parentIndex);
        }
    }

    pop() {
        this.heap[0] = this.heap.pop();
        this.shifDown(0);
    }

    // 下移
    shifDown(index) {
        const lastIndex = this.size() - 1;
        while (true) {
            // 左右不越界，取左右中最小的进行交换
            const leftIndex = this.getLeftIndex(index);
            const rightIndex = this.getRightIndex(index);
            let findIndex = index;
            if (leftIndex <= lastIndex && this.heap[leftIndex] < this.heap[findIndex]) {
                findIndex = leftIndex;
            }

            if (rightIndex <= lastIndex && this.heap[rightIndex] < this.heap[findIndex]) {
                findIndex = rightIndex;
            }

            if(index !== findIndex) {
                this.swap(findIndex, index);
                index = findIndex;
            } else {
                break;
            }
        }
        // 会超时
        // const left = this.getLeftIndex(index);
        // const right = this.getRightIndex(index);

        // if(this.heap[index] > this.heap[left]) {
        //     this.swap(index, left);
        //     this.shifDown(left);
        // }

        // if(this.heap[index] > this.heap[right]) {
        //     this.swap(index, right);
        //     this.shifDown(right);
        // }
    }
}
```

## 5.最大子序和

```js
// dp[i] = Math.max(nums[i], dp[i - 1] + nums[i])
// 只输出最大子序和
function maxSubArray(nums) {
    let pre = nums[0];
    let res = nums[0];

    for(let i = 1; i < nums.length; i++) {
        pre = Math.max(pre + nums[i], nums[i]);
        res = Math.max(res, pre);
    }

    return res;
}

console.log(maxSubArray([5,4,-1,7,8]));
console.log(maxSubArray([-2,1,-3,4,-1,2,1,-5,4]));

// 输出最大子序和的子序

function maxSubArray1(nums) {
    let pre = nums[0];
    let res = nums[0];
    let l = 0, r = 0; // 左右指针记录子序
    let resRange = [l, r];

    
    for(let i = 1; i < nums.length; i++) {
        if(pre + nums[i] > nums[i]) {
            r++;
            pre = pre + nums[i];
        } else {
            pre = nums[i];
            l = r = i;
        }

        if(res < pre) {
            res = pre;
            resRange = [l, r];
        }
    }

    return `和${res}: 子序：${nums.slice(resRange[0], resRange[1] + 1)}`
}

console.log(maxSubArray1([5,4,-1,7,8]));
console.log(maxSubArray1([-2,1,-3,4,-1,2,1,-5,4]));
```
## 6.最长公共子串和最长公共子序列

```js
// 子序列acd（可不连续） 子串ad(必须连续)

// 最长公共子序列
// dp[i][j] 
// 1. s[i] == s[j] 时, dp[i][j] = dp[i - 1][j - 1] + 1;
// 2. s[i] != s[j] 时, dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1])
var longestCommonSubsequence = function(s1, s2) {
    // dp[i][j] 以s1 第i结尾的子串和 s2第j个结尾的公共子串长度
    const dp = Array.from(new Array(s1.length + 1), () => new Array(s2.length + 1).fill(0));
    const c = Array.from(new Array(s1.length + 1), () => new Array(s2.length + 1).fill(0));
    for(let i = 1; i <= s1.length; i++) {
        const chart1 = s1[i - 1];
        for(let j = 1; j <= s2.length; j++) {
            const chart2 = s2[i - 1];
            if(chart1 == chart2) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
            } else if(dp[i - 1][j] > dp[i][j - 1]) {
                dp[i][j] = dp[i - 1][j];
                c[i][j] = 1;
            } else {
                dp[i][j] =  dp[i][j - 1];
                c[i][j] = -1;
            }
        }
    }

    let m = s1.length, n = s2.length, res = [];
    while(m != 0 && n != 0) {
        if(c[m][n] == 0) {
            res.push(s1[n])
            m--;
            n--;
        } else if(c[m][n] == -1) {
            n--;
        } else {
            m--;
        }
    }

    return `公共子序列： ${res.join('')}, 长度为： ${dp[s1.length][s2.length]}`
};

console.log(longestCommonSubsequence('abcadf', 'acdad'));
// 最长公共子串 'abcadf', 'acdad'
var longestCommonSubstring = function(s1, s2) {
    // 取s1和s2中短的作为s1
    if(s1.length > s2.length) {
        const temp = s1;
        s1 = s2;
        s2 = temp;
    }
    // dp[i][j] 以s1 第i结尾的子串和 s2第j个结尾的公共子串长度
    // dp[i][j] = 
    // s[i] === s[j] 时, dp[i][j] = dp[i - 1][j - 1] + 1;
    // s[i] !== s[j] 时, dp[i][j] = 0;
    const dp = Array.from(new Array(s1.length), () => new Array(s2.length).fill(0));
    let max = 0, start = 0;
    if(s1[0] == s2[0]) {
        dp[0][0] = 1;
    }
    
    for(let i = 1; i < s1.length; i++) {
        for(let j = 1; j < s2.length; j++) {
            if(s1[i] == s2[j]) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
            }
            if(dp[i][j] > max) {
                max = dp[i][j];
                start = i + 1 - max;
            }
        }
    }

    return s1.substr(start, max);
};
console.log(longestCommonSubstring('abcadf', 'acdad'));

```

## 7. 子串匹配

```js
function findSubstring(s, t) {
    for(let i = 0; i < s.length; i++) {
        let l = 0;
        while(l < t.length) {
            if(s[i + l] == t[l]) {
                l++
            } else {
                break;
            }
        }
        if(l == t.length) return i;
    }
    retrun -1;
}
console.log(findSubstring('ababcabcacbab', 'abcac'));

```

## 8. 无重复最长子串

```js
var lengthOfLongestSubstring = function(s) {
    // 滑动窗口
    const set = new Set();
    let r = 0, max = -1, res = '';
    for(let i = 0; i < s.length; i++) {
        if(i !== 0) {
            set.delete(s[i - 1]);
        }
        
        while(r < s.length && !set.has(s[r])) {
            set.add(s[r]);
            r++;
        }
        if(max < (r - i)) {
            max = r - i;
            res = s.substr(i, max);
        }  
    }
    return `公共子序无重复最长子串： ${res}, 长度为： ${max}`;
};

console.log(lengthOfLongestSubstring("abcabcbb"));
```

## 9.数列 𝑎的所有区间中，X 值最大的那个区间 X = min * sum

```js
// 分别计算以a[i] 为最小值的区间的X值，取最大

function maxValue(a) {
    const n = a.length;
    const left = new Array(n).fill(-1);
    const right = new Array(n).fill(n);
    let stack = [];

    // 找出左侧比a[i]小的最小值
    for(let i = 0; i < n; i++) {
        while(stack.length && stack[stack.length - 1] >= a[i]) {
            stack.pop();
        }
        if(stack.length) {
            left[i] = stack[stack.length - 1];
        }
        stack.push(a[i]);
    }
    stack = [];
    // i右侧比a[i]小的值
    for(let i = n - 1; i >=0; i--) {
        while(stack.length && stack[stack.length - 1] >= a[i]) {
            stack.pop();
        }
        if(stack.length) {
            right[i] = stack[stack.length - 1];
        }
        stack.push(a[i]);
    }

    let max = 0, maxRange = [0, 0];
    for(let i = 0; i < n; i++) {
        let sum = 0;
        for(let j = left[i] + 1; j < right[i]; j++) {
            sum += a[j];
        }
        const xValue = a[i] * sum;
        if(xValue > max) {
            max = xValue;
            maxRange = [left[i] + 1, right[i]];
        }
    }
    return {max, interval: a.slice(maxRange[0], maxRange[1])}
}

const a = [3,1,6,4,5,2];
const result = maxValue(a);
console.log(`X值最大的区间为 ${result.interval}  X = ${result.max}`);
```
## 10.中序遍历
> 左根右
```js
// 递归
var inorderTraversal = function(root) {
    const res = [];
    const inorder = (root) => {
        if(root == null) return;
        inorder(root.left);
        res.push(root.val);
        inorder(root.right);
    }
    inorder(root);
    return res;
};

// stack
var inorderTraversal = function(root) {
    const stack = [];
    const res = [];

    while(root) {
        stack.push(root);
        root = root.left;
    }
    while(stack.length) {
        let node = stack.pop();
        res.push(node.val);
        node = node.right;
        while(node) {
            stack.push(node);
            node = node.left;
        }
    }
    return res;
}
```

## 11. 二叉搜索树
```js
var isValidBST = function(root) {
    const stack = [];
    let front = -Infinity;

    while(root) {
        stack.push(root);
        root = root.left;
    }
    
    while(stack.length) {
        let node = stack.pop();
        if(node.val <= front) {
            return false;
        }
        front = node.val;
        while(node) {
            stack.push(node);
            node = node.right;
        }
    }
    return true;
}
```

## 12. 二叉树的层序遍历

```js
var levelOrder = function(root) {
    // 队列
    const queue = [];
    const res = [];

    if(root == null) return res;
    queue.push(root);

    while(queue.length) {
        const levelRes = [];
        const queueLength = queue.length;
        for(let i = 0; i < queueLength; i++) {
            const node = queue.shift();
            levelRes.push(node.val);
            node.left && queue.push(node.left);
            node.right && queue.push(node.right);
        }
        res.push(levelRes);
    }

    return res;
};
```

```js
var zigzagLevelOrder = function(root) {
    // 队列
    const queue = [];
    const res = [];
    let isEven = true;

    if(root == null) return res;
    queue.push(root);

    while(queue.length) {
        const levelRes = [];
        const queueLength = queue.length;
        for(let i = 0; i < queueLength; i++) {
            const node = queue.shift();
            if(isEven) {
                levelRes.push(node.val);
            } else {
                levelRes.unshift(node.val);
            }
            node.left && queue.push(node.left);
            node.right && queue.push(node.right);
        }
        isEven = !isEven;
        res.push(levelRes);
    }

    return res;
};
```

```js
var maxDepth = function(root) {
    const res = [];
    const dfs = (root, depth) => {
        if(root == null) {
            res.push(depth);
            return;
        }
        dfs(root.left, depth + 1);
        dfs(root.right, depth + 1);
    }
    return Math.max(...res);

    // 层序遍历记录有多少层
    if(root == null) return 0;
    const queue = [root];
    let depth = 1;
    while(queue.length) {
        const length = queue.length;
        for(let i = 0; i < length; i++) {
            const node = queue.shift();
            node.left && queue.push(node.left);
            node.right && queue.push(node.right);
        }
        if(queue.length) {
            depth++;
        }
    }
    return depth;
};
```

根据前序和中序 构造树
```js
function TreeNode(val, left, right) {
    this.val = (val===undefined ? 0 : val)
    this.left = (left===undefined ? null : left)
    this.right = (right===undefined ? null : right)
}
var buildTree = function(preorder, inorder) {
    const n = preorder.length;
    if(n == 0) return null;
    const leftSize = inorder.indexOf(preorder[0]);
    const left = buildTree(preorder.slice(1, leftSize + 1), inorder.slice(0, leftSize));
    const right = buildTree(preorder.slice(leftSize + 1), inorder.slice(leftSize + 1));
    return new TreeNode(preorder[0], left, right);
};
```

```js

// nums = [7, 1, 5, 3, 6, 4];
// 第i天交易完成手里没有股票的利润： dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + nums[i])
// 第i天交易完成手里有股票的利润： dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - nums[i])
function time(nums) {
    const n = nums.length;
    const dp = Array.from(new Array(n), () => new Array(2).fill(0));
    dp[0][1] = -nums[0];

    for(let i = 1; i < n; i++) {
        dp[i][0] =  Math.max(dp[i - 1][0], dp[i - 1][1] + nums[i]);
        dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - nums[i])
    }

    return dp[n - 1][0];
}

```

## 13.括号匹配
```js
// 1.输入 '([{}])' 输出 true
function match(s) {
    const map = {'(': ')', '[': ']', '{': '}'};
    const stack = [];
    for(let i = 0; i < s.length; i++) {
        if(map[s[i]] != undefined) {
            stack.push(s[i])
        } else {
            const temp = stack.pop();
            if(map[temp] != s[i]) {
                return false;
            }
        }
    }
    return stack.length == 0;
}
console.log(match('([{]})'))


// 2.输入n = 3 输出 ['((()))','(()())','(())()','()(()),()()()']

function gen(n){
    const res = [];
    const dfs = (l, r, str) => {
        if(str.length == n * 2) {
            res.push(str);
            return;
        }
        if(l > 0) {
            dfs(l - 1, r, str + '(')
        }
        if(r > l) {
            dfs(l, r - 1, str + ')')
        }
    };
    dfs(n, n, '');
    return res;
}

console.log(gen(3))
```
## 14.给正数n,求1 - n和为m的所有组合
```js

// 输入：candidates = 7, target = 8
// 输出：[[1,2,5],[1,3,4],[1,7],[2,6],[3,5]]
function findCombine(n, m) {
    const res = [];
    const dfs = (start, sum, arr) => {
        if(sum >= m) {
            if(sum == m) {
                res.push(arr.slice());
            }
            return;
        }

        for(let i = start; i <= n; i++) {
            arr.push(i);
            dfs(i + 1, sum + i, arr);
            arr.pop();
        }
    };

    dfs(1, 0, []);

    return res;
}
console.log(findCombine(7, 8))

// 输入：candidates = [2,3,6,7], target = 7
// 输出：[[2,2,3],[7]]

var combinationSum = function(candidates, target) {
    const res = [];

    const dfs = (start, arr, sum) => {
        if(sum >= target) {
            if(sum == target) {
                res.push(arr.slice());
            }
            return;
        }
        const curArr = arr.slice();
        for(let i = start; i < candidates.length; i++) {
            curArr.push(candidates[i]);
            dfs(i, curArr, sum + candidates[i]);
            curArr.pop();
        }
    }

    dfs(0, [], 0);
    return res;
};

console.log(combinationSum([2,3,5], 8))

// 输入：n = 4, k = 2
// 输出：
// [
//   [2,4],
//   [3,4],
//   [2,3],
//   [1,2],
//   [1,3],
//   [1,4],
// ]

var combine = function(n, k) {
    const res = [];
    const arr = [];
    const dfs = (start) => {
        if(arr.length == k) {
            res.push(arr.slice())
            return;
        }
        for(let i = start; i <= n; i++) {
            arr.push(i);
            dfs(i + 1);
            arr.pop();
        }
   } 

   dfs(1);

   return res;
};

console.log(combine(4, 2))
```
## 15.函数柯里化
> "函数柯里化：指封装一个函数，接收原始函数作为参数传入，并返回一个能够接收并处理剩余参数的函数"
```js
function curry(fn) {
    return function curried(...args) {
        if(args.length < fn.length) {
            return function(...nextArgs) {
                return curried.apply(this, args.concat(nextArgs));
            }
        }
        return fn.apply(this, args);
    }
}

function curry(fn) {
    return function curried(..args) {
        if(args.length < fn.length) {
            return function (...newArgs) {
                return curried.apply(this, args.concat(newArgs));
            }
        }
        return fn.apply(this, args);
    }
}

```
## 16.promise并发限制
```js
class LimitPromise {
    constructor(max) {
        this.max = max;
        this.queue = [];
        this.currentRunCount = 0;
        this.result = [];
        this.allTaskLen = taskList.length;
    }

    runTask({promise, index}) {
        return new Prmoise((resolve, reject) => {
            this.currentRunCount++;
            Promise.resolve(promise)
            .then((res) => {
                // resolve(res)
                result[index] = res;
            })
            .catch((err) => {
                // reject(err)
                result[index] = err;
            })
            .finally(() => {
                this.currentRunCount--;
                if(this.result.length == this.allTaskLen) {
                    
                }
                this.next();
            })
        })
    }

    push(promise, index) {
        if(this.currentRunCount < this.max) {
            this.runTask({promise, index});
        } else {
            this.queue.push({promise, index});
        }
    }

    next() {
        if(this.queue.length) {
            const {promise, index} = this.queue.shift();
            this.runTask({promise, index});
        }
    }

    runAllTask(taskList) {
        for(let i = 0; i < list.length; i++) {
            this.push({list[i], i});
        }
    }
}
const limitPromise = new LimitPromise(3);
Promise.all(tasks.map(task => limitPromise.push(task)));
```
## 17.最大子数组和
```js
// 输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
// 输出：6
var maxSubArray = function(nums) {
    let pre = nums[0];
    let max = nums[0];
    for(let i = 1; i < nums.length; i++) {
        // if(pre + nums[i] > nums[i]) {
        //     pre = pre + nums[i]
        // } else {
        //     pre = nums[i];
        // }
        pre = Math.max(pre + nums[i], nums[i]);
        max = Math.max(pre, max);
    }
    return max;
};
console.log(maxSubArray([-2,1,-3,4,-1,2,1,-5,4]))
```

## 18.cloneDeep
```js
function cloneDeep(target) {

    function isObject(obj) {
        return (obj && typeof obj == 'object') || typeof obj == 'function';
    }
    let map = new WeakMap();
    function clone(data) {
        // 非对象
        if(!isObject(data)) {
            return data;
        }

        // 函数
        if(typeof data == 'function') {
            return new Function( `return ${data.toString()}`)();
        }

        // date、regExp
        if([Date, RegExp].includes(data.constructor)){
            return data.constructor(data)
        }  
        
        // 循环引用
        if(map.has(data)) {
            return map.get(data);
        }
        
        // 处理map
        if(data instanceof Map) {
            const result = new Map();
            map.set(data ,result);
            data.forEach((val, key) => {
                if(isObject(val)) {
                    result.set(key, clone(val))
                } else {
                    result.set(key, val)
                }
            })
            return result;
        }

        // 处理set
        if(data instanceof Set) {
            const result = new Set();
            map.set(data, result);
            data.forEach(val => {
                if(isObject(val)) {
                    result.add(clone(val))
                } else {
                    result.add(val)
                }
            })
            return result;
        }

        //普通对象
        const keys = Reflect.ownKeys(data);
        const allDesc = Object.getOwnPropertyDescriptors(data);
        const result = Object.create(Object.getPrototypeOf(data), allDesc) 
        map.set(data, result);

        keys.forEach(key => {
            const val = data[key];
            if(isObject(val)) {
                result[key] = clone(val)
            } else {
                result[key] = val
            }
        })

        return result;
    }

    return clone(target);
}
```

## 19.call/apply/bind
```js
function myCall(context, ...args){
    context = context || window;
    const fn = Symbol();
    context[fn] = this;
    const result = context[fn](...args);
    delete context[fn];
    return result;
}

function myApply(context, args) {
    context = context || window;
    const fn = Symbol();
    context[fn] = this;
    const res = context[fn](...args);
    delete context[fn];
    return res;
}

function myBind(context, args) {
    context = context || window;
    const fn = this;
    const f = Symbol();
    const res = function(...args1) {
        if(this instanceof fn) {
            this[f] = fn;
            this[f](...args1, ...args);
            delete this[f];
        } else {
            context[f] = fn;
            context[f](...args1, ...args);
            delete context[f];
        }
    }
    res.prototype = Object.create(fn.prototype);
    return res;
}
```

## 20. new instanceof
```js
function myNew() {
    let obj = null, res = null;
    const constructor = Array.prototype.shift.call(arguments);

    obj = Objec.create(constructor.prototype);
    res = constructor.apply(obj, arguments);
    let flag = res && (typeof res == 'object' || typeof res == 'function');

    return flag ? res : obj;
}

function myInstanceof(left, right) {
    let proto = Object.getPrototypeOf(left);
    const prototype = right.prototype;
    while(true) {
        if(!proto) return false;
        if(proto == prototype) return ture;
        proto = Object.getPrototypeOf(proto);
    }
}
```

## 21. promise
```js
class Mypromise {
    constructor(fn) {
        this.state = 'pending';
        this.value = null;
        this.error = null;
        this.onFulfilledCallback = [];
        this.onRejectedCallback = [];

        const resolve = (value) => {
            if(this.state == 'pending') {
                this.state == 'fulfilled';
                this.value = value;
                this.onFulfilledCallback.forEach(callback => callback(this.value))
            }
        } 

        const reject = (error) => {
            if(this.state == 'pending') {
                this.state == 'rejected';
                this.error = error;
                this.onRejectedCallback.forEach(callback => callback(this.error))
            }
        } 

        try {
            fn(resolve, reject)
        } catch (err) {
            reject(err);
        }
    }

    then(onFulfilled, onRejected) {
        onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : value => value;
        onRejected = typeof onRejected === 'function' ? onRejected : reason => { throw reason };

        return new MyPromise((resolve, reject) => {

        });
    }

    catch(){

    }

    finally() {

    }
}
```

## 22. 扁平化

```js
const NestedIterator = function(nestedList) {
    this.stack = nestedList;
};
NestedIterator.prototype.hasNext = function() {
    while(this.stack.length) {
        const nest = this.stack[0];
        if(nest.isInteger) {
            return true;
        } else {
            const cur = this.stack[0].getList();
            this.stack.shift();
            this.stack.unshift(...cur);
        }
    }
    return false;
}

NestedIterator.prototype.next = function() {
    return this.stack.shift().getInteger();
}
// 方法1--栈
function flat(arr) {
    const res = [];
    const stack = [...arr];

    while(stack.length) {
        const val = stack.pop();
        if(Array.isArray(val)) {
            stack.push(...val);
        } else {
            res.unshift(val)
        }
    }
    return res;
}

// 方法2--reduce
function flat(arr) {
    return arr.reduce((pre, cur) => {
        return pre.concat(Array.isArray(cur) ? flat(cur) : cur)
    }, [])
}

function flat(arr, num = 1) {
    return num > 0 ? arr.reduce((pre, cur) => {
        return pre.concat(Array.isArray(cur) ? flat(cur, num - 1) : cur)
    }, []) : arr.slice();
}
```

## 23 递增三元子序列

```js
var increasingTriplet = function(nums) {
    const len = nums.length;
    if(len < 3) return false;
    // i左侧是否存在比nums[i]小的值
    const left = new Array(len).fill(false);
    // i右侧是否存在比nums[i]大的值
    const right = new Array(len).fill(false);
    let stack = [];
    for(let i = 0; i < len; i++) {
        while(stack.length && stack[stack.length - 1] > nums[i]) {
            stack.pop();
        }
        if(stack.length) {
            left[i] = true;
        }
        stack.push(nums[i])
    }
    stack = [];
    for(let i = len; i >= 0; i--) {
        while(stack.length && stack[stack.length - 1] < nums[i]) {
            stack.pop();
        }
        if(stack.length) {
            right[i] = true;
        }
        stack.push(nums[i])
    }

    for(let i = 0; i < len; i++) {
        if(left[i] && right[i]) {
            return true;
        }
    }
    return false;
};


var increasingTriplet = function(nums) {
    const longest = [], count;
    const len = nums.length;
    if(len < 3) return false;

    for(let i = 0; i < len; i++) {
        count = 1;
        for(let j = 0; j < len; j++) {
            if(nums[i] < nums[j] && count < longest[j]){
                count = longest[j] + 1;
            }
        }
        longest.push(count);
        if(count >= 3) {
            return true;
        }
    }
    return false;
};

var increasingTriplet = function(nums) {
    const len = nums.length;
    if(len < 3) return false;
    let first = nums[0], second = Number.MAX_VALUE;
    for(let i = 0; i < len; i++) {
        const num = nums[i];
        if(num > second) {
            return true;
        } else if(num > first) {
            second = num;
        } else {
            first = num;
        }
    }
    return false;
};
console.log(increasingTriplet([1,2,3,4,5]))
// 输入：nums = [1,2,3,4,5]
// 输出：true
```

## 24.最长递增子序列
```js
var lengthOfLIS = function(nums) {
    // dp[i]以i结束的递增子序列长度
    const len = nums.length;
    const dp = new Array(len).fill(1);
    for(let i = 0; i < len; i++) {
        for(let j = 0; j < i; j++) {
            if(nums[i] > nums[j]) {
                dp[i] = Math.max(dp[i], dp[j] + 1);
            }
        }
    }
    return Math.max(...dp);
};

console.log(lengthOfLIS([10,9,2,5,3,7,101,18]))
```

```js
// 给定一个包含 n + 1 个整数的数组 nums ，其数字都在 [1, n] 范围内（包括 1 和 n），可知至少存在一个重复的整数。

// 假设 nums 只有 一个重复的整数 ，返回 这个重复的数 。

// 你设计的解决方案必须 不修改 数组 nums 且只用常量级 O(1) 的额外空间。
var findDuplicate = function(nums) {
    // const len = nums.length;
    // let sum = 0;
    // let baseSum = 0;
    // for(let i = 1; i < len; i++) {
    //     baseSum += i;
    // }
    // for(let i = 0; i < len; i++) {
    //     sum += nums[i];
    // }

    // return sum - baseSum;

    // 二分法
    let l = 1, r = nums.length - 1;
    while(l < r) {
        let m = Math.floor((l + r) / 2);
        let count = 0;
        for(let i = 0; i < nums.length; i++) {
            if(nums[i] <= m) {
                count++;
            }
        }
        if(count > m) {
            r = m;
        } else {
            l = m + 1;
        }
    }
    return l;
};
console.log(findDuplicate([1,3,4,2,2]))


输入：nums = [1,3,4,2,2]
输出：2
```

## 25. 智力题
> 岛上有10只黑色的变色龙，14只白色的变色龙，15只灰色的变色龙，两只不同颜色的相遇就会变成第三种颜色，请问岛上变色龙有没有可能变成同一种颜色；
10、14、15
有
```js
function mergeColor(list) {
    let res = false;
    const dfs = (arr) => {
        const sum = arr.reduce((pre, cur) => pre + cur, 0);
        if(sum <= 1) {
            if(sum == 1) {
                res = true;
                console.log(arr.slice(), 'arr')
            }
            return;
        }
        const [a, b, c] = arr.sort();
        dfs([a+1, b - 1, c- 1]);
    };
    dfs(list)
    return res;
}

console.log(mergeColor([10,14, 15])) // true
```

## 26.翻转链表

```js
function reverseList(head) {

    let pre = null;
    let cur = head;
    let next = head.next;
    while(cur) {
        cur.next = pre;
        pre = cur;
        cur = next;
        next = cur.next
    }
    return pre;
}

```

## 27.岛屿数量 200
给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。

岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。

此外，你可以假设该网格的四条边均被水包围。

 

示例 1：

输入：grid = [
  ["1","1","1","1","0"],
  ["1","1","0","1","0"],
  ["1","1","0","0","0"],
  ["0","0","0","0","0"]
]
输出：1
示例 2：

输入：grid = [
  ["1","1","0","0","0"],
  ["1","1","0","0","0"],
  ["0","0","1","0","0"],
  ["0","0","0","1","1"]
]
输出：3
 

提示：

m == grid.length
n == grid[i].length
1 <= m, n <= 300
grid[i][j] 的值为 '0' 或 '1'

```js

function numIslands(grid) {
    const m = grid.length;
    const n = grid[0].length;
    let res = 0;

    const dfs = (i, j) => {
        if(i < 0 || j < 0 || i >= m || j >= n || grid[i][j] == 0) {
            return;
        }
        grid[i][j] = 0;
        dfs(i - 1, j);
        dfs(i + 1, j);
        dfs(i, j - 1);
        dfs(i, j + 1);
    }

    for(let i = 0; i < m; i++) {
        for(let j = 0; j < n; j++) {
            if(grid[i][j] == 1) {
                res++;
                dfs(i, j);
            }
        }
    }

    return res;  
}

console.log(numIslands([
  ["1","1","0","0","0"],
  ["1","1","0","0","0"],
  ["0","0","1","0","0"],
  ["0","0","0","1","1"]
]))

```
## 28. 实现排序

## 29 lc394:字符串解码
输入：s = "3[a]2[bc]"
输出："aaabcbc"

```js
    var decodeString = function(s) {
        let numStack = [];
        let strStack = [];
        let num = 0;
        let result = '';

        for(let i = 0; i < s.length; i++) {
            if(!isNaN(s[i])) {
                num = num * 10 + Number(s[i])
            } else if(s[i] == '[') {
                strStack.push(result);
                result = ''
                numStack.push(num);
                num = 0;
            } else if (s[i] == ']') {
                const repeatNum = numStack.pop();
                result = strStack.pop() + result.repeat(repeatNum);

            } else {
                result += s[i]
            }
        }
        return result;

    };
    console.log(decodeString("abc3[cd]xyz"))
```

## 30.两个有序数组排序
```js
function sortTwoArray(nums1, nums2) {
    let res = [];
    let l1 = 0, l2 = 0;
    while(l1 < nums1.length && l2 < nums2.length) {
        if(nums1[l1] < nums2[l2]) {
            res.push(nums1[l1]);
            l1++
        } else {
            res.push(nums2[l2]);
            l2++
        }
    }

    l1 == nums1.length ? res.concat(nums2.slice(l2)) : res.concat(nums1.slice(l1));

    return res;
}

console.log(sortTwoArray([1, 2, 4, 6, 7, 9], [3, 5, 6, 7, 7, 8, 9, 9]))
```

## 31.给一个DOM结构的字符串，如何计算每个标签的数量

## 32.
给定一个整型二维数组 (每个一维数组的长度大于0但不固定)，每一行从左到右递增，每行的第一个整数大于前一行的最后一个整数。
要求:实现一个函数，接收这样的二维数组array 和一个整数X，返回该整数在二维数组中的下标(用数组表示，例如`[12]`) ，如果不存在则返回`[-1,-1]`
-示例: 给定 array=[1,3,5,6],[7,8,9],[10,14]若 X=9 则返回[1,2]; 若 X=11 则返回[-1,-1]


## 33.3. 一个异步调度器

```js
class AsyncScheduler {
    constructor(max) {
        this.max = max;
        this.queue = [];
        this.currentCount = 0;
    } 

    add(task) {
        return new Promise((resolve, reject) => {
            this.queue.push({task, resolve, reject});
            this.next();
        })
    }

    next() {
        if(this.currentCount < this.max && this.queue.length > 0) {
            const {task, resolve, reject} = this.queue.shift();
            this.currentCount++;
            task().then(resolve, reject).finally(( ) => {
                this.currentCount--;
                this.next();
            })
        }
    }

}
```
## 34. 递归判断回文字符串

```js

```

## 35. 手写 Promise.race
```js
function myPromiserace(promiseArr) {
    if(!Array.isArray(promiseArr)) {
        return new TypeError(`expected an array,but get ${typeof promiseArr}`)
    }
    return new Promise((resolve, reject) => {
        for(let i = 0; i < promiseArr.length; i++) {
            Promise.resolve(promiseArr[i]).then(resolve, reject)
        }
    })
}
```
## 36. 实现一个 useOnce hook：

```js
const fn = () => console.log(1)
const newFn = useOnce(fn)

const clickHandler = () => {
    newFn() // 只触发一次
}

function useOnce(fn) {
    let hasRun = false;

    return function (...args) {
        if(!hasRun) {
            hasRun = true;
            return fn.apply(this, args);
        }
    }
}
```

## 37 手写sqrt算法
给你一个非负整数 x ，计算并返回 x 的 算术平方根 。
由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。
注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。

示例 1：

输入：x = 4
输出：2

```js
function mySqrt(n) {
    if(n < 2) {
        return n;
    }

    let l = 1, m, r = n;

    while(l <= r) {
        m = Math.floor((l + r) / 2);
        m = l + ((r - l) >> 1);
        const value = m * m;
        if(value == n) {
            return m
        } else if (value < n) {
            l = m + 1
        } else {
            r = m - 1
        }
    }
}
```

## 38 手写CSS扇形，颜色是白色，底色为黑
```css
/* <div class="box">
    <div class="shanxing"></div>
</div> */
.box {
    position: relative;
    display: flex;
    align-items: center;
    justify-content: center;
    width: 200px;
    height: 200px;
    overflow: hidden;
    background-color: #000;
}

.shanxing {
    position: absolute;
    top: 50px;
    left: 0;
    width: 0;
    height: 0;
    border: 100px solid;
    border-color: #fff transparent transparent transparent;
    border-radius: 100px;
    transform: rotate(0deg);
}~
```
## 39 算法:01背包


## 40 算法:螺旋数组
输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
输出：[1,2,3,4,8,12,11,10,9,5,6,7]

```js
function spiralOrder (matrix) {
    const res = [];
    const m = matrix.length, n = matrix[0].length;

    let top = 0, bottom = m - 1, left = 0, right = n - 1;

    while(top <= bottom && left <= right) {
        // 先top
        for(let i = left; i <= right; i++) {
            res.push(matrix[top][i])
        }
        top++;
        // 右
        for(let i = top; i <= bottom; i++) {
            res.push(matrix[i][right]);
        }
        right--;
        //bottom
        if(top <= bottom) {
            for(let i = right; i >= left; i--) {
                res.push(matrix[bottom][i])
            }
        }
        bottom--;
        //left
        if(left <= right) {
            for(let i = bottom; i >=top; i--) {
                res.push(matrix[i][left])
            }
        }
        left++
    }

    return res;
}

console.log(spiralOrder([[1,2,3,4],[5,6,7,8],[9,10,11,12]]))
```


## 41 Z 字形变换
将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列。
比如输入字符串为 "PAYPALISHIRING" 行数为 3 时，排列如下：

P   A   H   N
A P L S I I G
Y   I   R
之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如："PAHNAPLSIIGYIR"。

请你实现这个将字符串进行指定行数变换的函数：

string convert(string s, int numRows);

```js
function convert(s, numRows) {
    const n = s.length ,r = numRows;
    if(r == 1 || n <= r) {
        return s;
    }
    // 一个周期的长度
    const t = r + r - 2;

    const arr = Array.from(new Array(r), () => new Array(Math.ceil(n / t) * (r - 1)).fill(0));

    let row = 0, col = 0;
    for(let i = 0; i < n; i++) {
        arr[row][col] = s[i];
        if((i % t) < r - 1) {
            row++
        } else {
            row--;
            col++;
        }
    }
    let res = '';
    for(let i = 0; i < r; i++) {
        for(let j = 0; j < arr[0].length; j++) {
            if(arr[i][j] != 0) {
                res += arr[i][j]
            }
        }
    }
    return res;
}

console.log(convert("PAYPALISHIRING", 3))
```

## 42 算法：树的遍历有几种方式，实现下层次遍历

```js
// 深度优先、广度优先遍历



```

## 43 算法：判断对称二叉树

```js
function isSymmetric(root) {
    function isSameTree(p, q) {
        if(p == null || q == null) {
            return p == q
        }

        return p.val == q.val && isSameTree(p.left, q.right) && isSameTree(p.right, q.left);
    }
    return isSameTree(root.left, root.right);
}
```

## 44算法题：
> 老师分饼干，每个孩子只能得到一块饼干，但每个孩子想要的饼干大小不尽相同。目标是尽量让更多的孩子满意。如孩子的要求是 1, 3, 5, 4, 2，饼干是1, 1，最多能让1个孩子满足。如孩子的要求是 10, 9, 8, 7, 6，饼干是7, 6, 5，最多能让2个孩子满足。

```js
function findContentChildren(children, cookies) {
    // 将孩子的需求和饼干大小进行排序
    children.sort((a, b) => a - b);
    cookies.sort((a, b) => a - b);

    let childPointer = 0; // 孩子指针
    let cookiePointer = 0; // 饼干指针
    let satisfiedChildren = 0; // 满足的孩子数

    while (childPointer < children.length && cookiePointer < cookies.length) {
        if (cookies[cookiePointer] >= children[childPointer]) {
            // 当前饼干可以满足当前孩子
            satisfiedChildren++;
            childPointer++; // 满足后，移动到下一个孩子
        }
        cookiePointer++; // 无论是否满足，饼干指针都要移动
    }

    return satisfiedChildren;
}
```
## 45 算法题：两个有序链表和并成一个有序链表

```js
var mergeTwoLists = function(list1, list2) {
    const prehead = new ListNode(-1);
    let prev = prehead;

    while(list1 != null && list2 != null) {
        if(list1.val <= list2.val) {
            prev.next = list1;
            list1 = list1.next;
        } else {
            prev.next = list2;
            list2 = list2.next;
        }
        prev = prev.next;
    }

    prev.next = list1 == null ? list2 : list1;

    return prehead.next;
}
```


## 46 算法: 版本号排序
样例输入：versions = ['0.1.1', '2.3.3', '0.302.1', '4.2', '4.3.5', '4.3.4.5']
输出：['0.1.1', '0.302.1', '2.3.3', '4.3.4.5', '4.3.5']

```js
function versionSort(arr) {
    return arr.sort((a, b) => {
        const tempA = a.split('.');
        const tempB = b.split('.');
        const maxLen = Math.max(tempA.length, tempB.length);
        for(let i = 0; i < maxLen; i++) {
            const curA = tempA[i] || 0;
            const curB = tempB[i] || 0;
            if(curA > curB) {
                return 1;
            } else if(curA < curB) {
                return -1;
            }
        }
        return 0;
    });
}

console.log(versionSort(['0.1.1', '2.3.3', '0.302.1', '4.2', '4.3.5', '4.3.4.5']))
```

## 47 数组去重
```  
[{a:1, b:2},{a:1},{a:1}, {a:1, b:{c:1}}, {b:{c:1}, a:1}]
  => [{a:1, b:2}, {a:1}, {a:1, b:{c:1}}]
```

```js
function removeRepate(arr) {
    const set = new Set();
    const res = [];

    for(let i = 0; i < arr.length; i++) {
        const sortItem = removeRepateObj(arr[i]);
        const curItem = JSON.stringify(sortItem);
        if(!set.has(curItem)) {
            set.add(curItem);
            res.push(sortItem)
        }
    }
    return res;
}

function removeRepateObj(obj) {

    if(typeof obj !== 'object') {
        return obj
    }

    return Object.keys(obj).sort().reduce((sortObj, cur) => {
        sortObj[cur] = removeRepateObj(obj[cur]);

        return sortObj;
    }, {})
}

console.log(removeRepate([{a:1, b:2},{a:1},{a:1}, {a:1, b:{c:1}}, {b:{c:1}, a:1}]))
```

## 48 算法
> 提供了一个RedPackage的类，初始化时传入红包金额和个数，需要实现一个openRedPackage方法，每调一次都进行一次“抢红包”，并以console.log的形式输出抢到的红包金额。
```js
class RedPackage {
    constructor(money, num) {
        this.totalAmount = money;
        this.totalCount = num;
        this.remainingAmount = money;
        this.remainingCount = num;
    }

    openRedPackage() {
        if(this.remainingCount == 0) {
            console.log('红包已经抢完了');
            return;
        }

        let amount;
        const MIN_AMOUNT = 0.01;

        if(this.remainingCount == 1) {
            amount = this.remainingAmount;
        } else {
            amount = +((Math.random() * this.remainingAmount - (this.remainingCount * MIN_AMOUNT)).toFixed(2));
            amount = Math.max(MIN_AMOUNT, amount);
        }

        this.remainingAmount -= amount;
        this.remainingCount--;

        console.log(`抢到红包jine: ${amount.toFixed(2)}, 剩余${this.remainingAmount}`);
    }
}
const redPackage = new RedPackage(100, 10);
for (let i = 0; i <= 10; i++) {
    redPackage.openRedPackage(); // 每次调用模拟一次抢红包
}
```