参考文章
[带你了解更全面的 MonoRepo - 优劣、踩坑、选型](https://juejin.cn/post/7215886869199896637)
[cankao](https://howieyuen.github.io/docs/getting-started/MonoRepo/)
[All in one：项目级 monorepo 策略最佳实践](https://segmentfault.com/a/1190000039157365)

**MonoRepo**，即单一代码库（Monolithic Repository），是将多个项目或组件的代码存储在同一个版本控制系统仓库中的一种源代码管理策略。大公司如 Google、Facebook、Twitter 等都采用了 `MonoRepo` 来管理他们庞大的代码库。

## 利弊分析
###### 优势：

+ 代码共享和重用：在 `MonoRepo` 中，所有项目共享同一个仓库，这使得代码的复用变得非常容易。不同项目之间可以轻松共享公共库和工具。
+ 统一的版本控制：`MonoRepo` 确保所有项目和组件都基于同一套版本控制规则，这有利于维持代码的一致性。
+ 原子提交：开发者可以在一个提交中修改多个项目或者组件，这样的改动可以保证原子性，易于追溯和回滚。
+ 简化的依赖管理：由于所有的代码和项目都在同一个仓库中，因此管理项目间的依赖关系会更加直接和简单。
+ 集中的工具和脚本：构建、测试、部署等流程可以统一处理，避免了在多个仓库中重复设置相同的工具链和脚本。

###### 劣势：

+ 代码库规模庞大：当代码库变得极其庞大时，克隆、拉取更新和查找历史记录可能会变得缓慢。
+ 权限管理复杂：如果需要对代码库中的不同部分设置不同的访问权限，那么在 `MonoRepo` 环境下这可能会更加复杂。
+ 构建效率：如果没有有效的构建缓存和依赖管理，任何小的改动都可能触发整个仓库的构建，这会大大降低构建效率。
+ 学习曲线：新加入的开发者可能需要更多的时间来熟悉一个巨大的代码库，而不是一个小而专注的项目仓库。
+ 工具适配：不是所有的版本控制和持续集成工具都能很好地适应巨大的 `MonoRepo`，可能需要特定的或定制化的工具支持。

###### 适用场景：

+ 多项目依赖密切： 如果组织中的多个项目或组件密切相关，并且经常需要进行跨项目的改动，`MonoRepo` 可以提供更流畅的开发体验。
+ 需要强制统一标准： 当需要强制执行编码标准、依赖版本控制、工具链等一致性时，`MonoRepo` 可以更容易地实现这些要求。
+ 大型团队协作： 对于大型团队，`MonoRepo` 有助于协调不同团队成员之间的工作，因为它减少了项目间协调沟通的复杂性。
+ 快速迭代和部署： 如果组织需要快速迭代和部署多个相关组件，`MonoRepo` 可以简化这一过程，因为所有的变更都可以在一个提交中进行管理。

通过 `MonoRepo` 策略组织代码，您代码仓库的目录结构看起来会是这样：
```
.
├── lerna.json
├── package.json
└── packages/ # 这里将存放所有子 repo 目录
    ├── project_1/
    │   ├── index.js
    │   ├── node_modules/
    │   └── package.json
    ├── project_2/
    │   ├── index.js
    │   ├── node_module/
    │   └── package.json
    ...
```

3.2 复用 packages：workspace
使用 monorepo 策略后，收益最大的两点是：

避免重复安装包，因此减少了磁盘空间的占用，并降低了构建时间；
内部代码可以彼此相互引用；
这两项好处全部都可以由一个成熟的包管理工具来完成，对前端开发而言，即是 yarn（1.0 以上）或 npm（7.0 以上）通过名为 workspaces 的特性实现的（⚠️ 注意，支持 workspaces 特性的 npm 目前依旧不是 TLS 版本）。

为了实现前面提到的两点收益，您需要在代码中做三件事：

调整目录结构，将相互关联的项目放置在同一个目录，推荐命名为 packages；
在项目根目录里的 package.json 文件中，设置 workspaces 属性，属性值为之前创建的目录；
同样，在 package.json 文件中，设置 private 属性为 true（为了避免我们误操作将仓库发布）；
经过修改，您的项目目录看起来应该是这样：
```
.
├── package.json
└── packages/
    ├── @mono/project_1/ # 推荐使用 `@<项目名>/<子项目名>` 的方式命名
    │   ├── index.js
    │   └── package.json
    └── @mono/project_2/
        ├── index.js
        └── package.json

```
而当您在项目根目录中执行 npm install 或 yarn install 后，您会发现在项目根目录中出现了 node_modules 目录，并且该目录不仅拥有所有子项目共用的 npm 包，还包含了我们的子项目。因此，我们可以在子项目中通过各种模块引入机制，像引入一般的 npm 模块一样引入其他子项目的代码。

请注意我们对子项目的命名，统一以 @<repo_name>/ 开头，这是一种社区最佳实践，不仅可以让用户更容易了解整个应用的架构，也方便您在项目中更快捷的找到所需的子项目。

至此，我们已经完成了 monorepo 策略的核心部分，实在是很容易不是吗？但是老话说「行百里者半九十」，距离优雅的搭建一个 monorepo 项目，我们还有一些路要走。