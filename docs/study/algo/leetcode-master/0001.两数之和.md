

## 1. 两数之和

[力扣题目链接](https://leetcode.cn/problems/two-sum/)

给定一个整数数组 nums  和一个目标值 target，请你在该数组中找出和为目标值的那   两个   整数，并返回他们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。

**示例:**

给定 nums = [2, 7, 11, 15], target = 9

因为 nums[0] + nums[1] = 2 + 7 = 9

所以返回 [0, 1]

## 思路

建议看一下我录的这期视频：[梦开始的地方，Leetcode：1.两数之和](https://www.bilibili.com/video/BV1aT41177mK)，结合本题解来学习，事半功倍。

很明显暴力的解法是两层 for 循环查找，时间复杂度是 O(n^2)。

建议大家做这道题目之前，先做一下这两道

- [242. 有效的字母异位词](https://www.programmercarl.com/0242.有效的字母异位词.html)
- [349. 两个数组的交集](https://www.programmercarl.com/0349.两个数组的交集.html)

[242. 有效的字母异位词](https://www.programmercarl.com/0242.有效的字母异位词.html) 这道题目是用数组作为哈希表来解决哈希问题，[349. 两个数组的交集](https://www.programmercarl.com/0349.两个数组的交集.html)这道题目是通过 set 作为哈希表来解决哈希问题。

首先我在强调一下 **什么时候使用哈希法**，当我们需要查询一个元素是否出现过，或者一个元素是否在集合里的时候，就要第一时间想到哈希法。

本题呢，我就需要一个集合来存放我们遍历过的元素，然后在遍历数组的时候去询问这个集合，某元素是否遍历过，也就是 是否出现在这个集合。

那么我们就应该想到使用哈希法了。

因为本地，我们不仅要知道元素有没有遍历过，还有知道这个元素对应的下标，**需要使用 key value 结构来存放，key 来存元素，value 来存下标，那么使用 map 正合适**。

再来看一下使用数组和 set 来做哈希法的局限。

- 数组的大小是受限制的，而且如果元素很少，而哈希值太大会造成内存空间的浪费。
- set 是一个集合，里面放的元素只能是一个 key，而两数之和这道题目，不仅要判断 y 是否存在而且还要记录 y 的下标位置，因为要返回 x 和 y 的下标。所以 set 也不能用。

此时就要选择另一种数据结构：map ，map 是一种 key value 的存储结构，可以用 key 保存数值，用 value 在保存数值所在的下标。


接下来需要明确两点：

- **map 用来做什么**
- **map 中 key 和 value 分别表示什么**

map 目的用来存放我们访问过的元素，因为遍历数组的时候，需要记录我们之前遍历过哪些元素和对应的下标，这样才能找到与当前元素相匹配的（也就是相加等于 target）

接下来是 map 中 key 和 value 分别表示什么。

这道题 我们需要 给出一个元素，判断这个元素是否出现过，如果出现过，返回这个元素的下标。

那么判断元素是否出现，这个元素就要作为 key，所以数组中的元素作为 key，有 key 对应的就是 value，value 用来存下标。

所以 map 中的存储结构为 {key：数据元素，value：数组元素对应的下标}。

在遍历数组的时候，只需要向 map 去查询是否有和目前遍历元素匹配的数值，如果有，就找到的匹配对，如果没有，就把目前遍历的元素放进 map 中，因为 map 存放的就是我们访问过的元素。

过程如下：

![过程一](https://code-thinking-1253855093.file.myqcloud.com/pics/20220711202638.png)

![过程二](https://code-thinking-1253855093.file.myqcloud.com/pics/20230220223536.png)


## 总结

本题其实有四个重点：

- 为什么会想到用哈希表
- 哈希表为什么用 map
- 本题 map 是用来存什么的
- map 中的 key 和 value 用来存什么的

把这四点想清楚了，本题才算是理解透彻了。

很多录友把这道题目 通过了，但都没想清楚 map 是用来做什么的，以至于对代码的理解其实是 一知半解的。


Javascript

```javascript
var twoSum = function (nums, target) {
  let hash = {};
  for (let i = 0; i < nums.length; i++) {
    // 遍历当前元素，并在map中寻找是否有匹配的key
    if (hash[target - nums[i]] !== undefined) {
      return [i, hash[target - nums[i]]];
    }
    hash[nums[i]] = i; // 如果没找到匹配对，就把访问过的元素和下标加入到map中
  }
  return [];
};
```

TypeScript：

```typescript
function twoSum(nums: number[], target: number): number[] {
  let helperMap: Map<number, number> = new Map();
  let index: number | undefined;
  let resArr: number[] = [];
  for (let i = 0, length = nums.length; i < length; i++) {
    index = helperMap.get(target - nums[i]);
    if (index !== undefined) {
      resArr = [i, index];
    }
    helperMap.set(nums[i], i);
  }
  return resArr;
}
```