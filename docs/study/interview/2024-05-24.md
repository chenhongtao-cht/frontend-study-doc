## 1. vue中的diff算法的源码中是怎么做的？
在Vue的diff算法源码中，主要通过一种叫做"双端比较"（double-end comparison）的算法来比较新旧虚拟DOM树，找出变化并进行最小量的DOM操作。这个过程发生在patch函数中，以下是对其主要步骤的解析：

初始化与入口： 在Vue的虚拟DOM更新过程中，patch函数是入口。它的作用是对比新旧虚拟DOM树，并对实际的DOM进行必要的更新。

```js
function patch(oldVnode, vnode, hydrating, removeOnly) {
 // ...
 if (!oldVnode) {
   // 新节点，创建并插入
   createElm(vnode, insertedVnodeQueue, parentElm, refElm);
 } else {
   // 更新已有节点
   const isRealElement = oldVnode.nodeType !== undefined;
   if (!isRealElement && sameVnode(oldVnode, vnode)) {
     // 同类型节点，做diff操作
     patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly);
   } else {
     // 其他情况，重新创建
     createElm(vnode, insertedVnodeQueue, parentElm, refElm);
   }
 }
 // ...
}
```
sameVnode函数： 判断两个节点是否为相同节点，通过tag、key等属性判断。

```js
function sameVnode(a, b) {
 return (
   a.key === b.key &&
   a.tag === b.tag &&
   a.isComment === b.isComment &&
   isDef(a.data) === isDef(b.data) &&
   sameInputType(a, b)
 );
}
```
patchVnode函数： 是核心diff逻辑所在。它会递归对比新旧节点的子节点。

```js
function patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly) {
 // ... 省略了一些更新属性和事件的代码

 const oldCh = oldVnode.children;
 const ch = vnode.children;
 if (isDef(ch) && isDef(oldCh)) {
   if (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly);
 } else if (isDef(ch)) {
   // 旧节点无子节点，新节点有子节点
   createChildren(vnode, ch, insertedVnodeQueue);
 } else if (isDef(oldCh)) {
   // 新节点无子节点，旧节点有子节点
   removeVnodes(elm, oldCh, 0, oldCh.length - 1);
 }
 // ... 省略了一些其他情况处理代码
}
```
updateChildren函数： 进行双端比较的核心函数。它维护四个指针，分别指向新旧节点数组的头尾，通过一系列条件判断更新DOM。

 ```js
function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
  let oldStartIdx = 0;
  let newStartIdx = 0;
  let oldEndIdx = oldCh.length - 1;
  let newEndIdx = newCh.length - 1;
  let oldStartVnode = oldCh[oldStartIdx];
  let oldEndVnode = oldCh[oldEndIdx];
  let newStartVnode = newCh[newStartIdx];
  let newEndVnode = newCh[newEndIdx];
  let oldKeyToIdx, idxInOld, vnodeToMove, refElm;

  while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
    // ... 一系列复杂的比较逻辑
    if (sameVnode(oldStartVnode, newStartVnode)) {
      patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, removeOnly);
      oldStartVnode = oldCh[++oldStartIdx];
      newStartVnode = newCh[++newStartIdx];
    } else if (sameVnode(oldEndVnode, newEndVnode)) {
      patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, removeOnly);
      oldEndVnode = oldCh[--oldEndIdx];
      newEndVnode = newCh[--newEndIdx];
    } else if (sameVnode(oldStartVnode, newEndVnode)) {
      // Vnode moved right
      patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, removeOnly);
      canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));
      oldStartVnode = oldCh[++oldStartIdx];
      newEndVnode = newCh[--newEndIdx];
    } else if (sameVnode(oldEndVnode, newStartVnode)) {
      // Vnode moved left
      patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, removeOnly);
      canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
      oldEndVnode = oldCh[--oldEndIdx];
      newStartVnode = newCh[++newStartIdx];
    } else {
      // 处理其他情况
      if (!oldKeyToIdx) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
      idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : null;
      if (!isDef(idxInOld)) {
        // New element
        createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);
        newStartVnode = newCh[++newStartIdx];
      } else {
        vnodeToMove = oldCh[idxInOld];
        if (sameVnode(vnodeToMove, newStartVnode)) {
          patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, removeOnly);
          oldCh[idxInOld] = undefined;
          canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);
        } else {
          // same key but different element. treat as new element
          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);
        }
        newStartVnode = newCh[++newStartIdx];
      }
    }
  }
  // 添加剩余的节点
  if (oldStartIdx > oldEndIdx) {
    refElm = isDef(newCh[newEndIdx + 1]) ? newCh[newEndIdx + 1].elm : null;
    addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
  } else if (newStartIdx > newEndIdx) {
    removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
  }
}
```
通过以上核心步骤，Vue实现了高效的虚拟DOM diff算法。它通过双端比较和key的使用，在保证最小化DOM操作的同时，确保了节点的正确更新。

## 2. Vue3相比Vue2源码在diff算法层面上的优化
Vue.js 是一个流行的前端框架，其核心之一是高效的虚拟 DOM diff 算法。在 Vue 3 中，diff 算法相较于 Vue 2 进行了多项优化和改进，以提升性能和开发体验。以下是一些关键的优化点：

1. 编译阶段的优化

Vue 3 在编译阶段做了更多优化，使得生成的渲染函数更高效。通过静态分析模板，Vue 3 可以确定哪些部分是动态的，哪些是静态的，从而减少运行时的 diff 操作。

静态提升

在 Vue 3 中，编译器会将静态节点提升到渲染函数之外，避免每次渲染时都重新创建相同的静态节点。

```js
// Vue 3
const render = (ctx) => {
  return [/* 静态节点 */, .../* 动态节点 */];
};
```
2. Block Tree 结构

Vue 3 引入了 Block Tree 结构，使得只对动态部分进行更新成为可能。Block 是由动态节点组成的树结构，编译器会将模板划分为多个 block。

Patch Flags

编译器会生成 patch flags，用于标识动态节点的变化类型。这使得运行时只需要检查标记的部分，减少不必要的比较。

 ```js
const patchFlags = {
  TEXT: 1,
  CLASS: 2,
  STYLE: 4,
  // 其他标志
};
```
3. 更高效的 DOM Diff 算法

Vue 3 在 DOM diff 算法上进行了改进，提升了性能和效率。

+ 双端比较

Vue 3 采用双端比较（双指针）策略，在处理节点移动时更加高效。

 ```js
function patchKeyedChildren(c1, c2) {
  let i = 0;
  let e1 = c1.length - 1;
  let e2 = c2.length - 1;

  // 头到头比较
  while (i <= e1 && i <= e2 && isSameVNode(c1[i], c2[i])) {
    patch(c1[i], c2[i]);
    i++;
  }

  // 尾到尾比较
  while (e1 >= i && e2 >= i && isSameVNode(c1[e1], c2[e2])) {
    patch(c1[e1], c2[e2]);
    e1--;
    e2--;
  }

  // 其他情况处理
  // ...
}
```
+ 最长递增子序列

在处理节点顺序变化时，Vue 3 使用最长递增子序列算法（LIS）来最小化 DOM 操作。

 ```js
function getSequence(arr) {
  const p = arr.slice();
  const result = [0];
  let i, j, u, v, c;
  const len = arr.length;
  for (i = 0; i < len; i++) {
    const arrI = arr[i];
    if (arrI !== 0) {
      j = result[result.length - 1];
      if (arr[j] < arrI) {
        p[i] = j;
        result.push(i);
        continue;
      }
      u = 0;
      v = result.length - 1;
      while (u < v) {
        c = (u + v) >> 1;
        if (arr[result[c]] < arrI) {
          u = c + 1;
        } else {
          v = c;
        }
      }
      if (arrI < arr[result[u]]) {
        if (u > 0) {
          p[i] = result[u - 1];
        }
        result[u] = i;
      }
    }
  }
  u = result.length;
  v = result[u - 1];
  while (u-- > 0) {
    result[u] = v;
    v = p[v];
  }
  return result;
}
```
4. 渲染性能优化

Vue 3 在渲染性能上做了多项优化，使得在处理复杂组件树和大量动态节点时更加高效。

+ Fragment 支持

Vue 3 支持 Fragment，使得可以在不引入额外 DOM 元素的情况下，渲染多个子节点。这在某些场景下可以减少 DOM 操作。

 ```js
const Fragment = Symbol('Fragment');

function renderFragment(children) {
  return {
    type: Fragment,
    children,
  };
}
```
+ 自定义渲染器
Vue 3 允许用户创建自定义渲染器（Custom Renderer），以适应不同的渲染环境（如原生应用、Canvas 等）。

 ```js
import { createRenderer } from 'vue';

const { render, createApp } = createRenderer({
  patchProp,
  insert,
  remove,
  createElement,
  // ...
});
```
5. 内存优化

Vue 3 通过改进组件的内部结构和减少不必要的内存分配，提升了内存使用效率。

+ Proxy 代理
Vue 3 使用 ES6 Proxy 进行响应式数据的实现，相较于 Vue 2 的 Object.defineProperty，Proxy 可以更高效地处理动态属性的添加和删除。

 ```js
const reactiveHandler = {
  get(target, key) {
    // 依赖收集
    return Reflect.get(target, key);
  },
  set(target, key, value) {
    // 触发更新
    return Reflect.set(target, key, value);
  },
};

function reactive(target) {
  return new Proxy(target, reactiveHandler);
}
```
**总结**

Vue 3 在 diff 算法上进行了多项优化和改进，主要包括编译阶段的静态提升、Block Tree 结构、双端比较策略、最长递增子序列算法、Fragment 支持和 Proxy 代理等。这些优化使得 Vue 3 在处理复杂组件树和大量动态节点时性能更高、内存使用更高效，从而提升了整体的开发体验和应用性能。

## 3. vue3组件通信声明周期
在 Vue 3 中，组件通信的生命周期钩子主要通过 setup 函数中的响应式变量和生命周期函数实现。相较于 Vue 2.x 的选项式 API，Vue 3 使用了 Composition API，使得组件通信更加灵活和直观。以下是 Vue 3 组件通信的主要生命周期钩子：

1. setup 函数
setup 函数是 Vue 3 中组件配置的入口，用于设置组件的响应式变量和生命周期函数。

使用方式：
 ```js
import { ref, reactive, onMounted } from 'vue';

export default {
  setup() {
    // 声明响应式变量
    const count = ref(0);
    const state = reactive({
      message: 'Hello Vue 3!',
    });

    // 生命周期钩子
    onMounted(() => {
      console.log('Component mounted');
    });

    // 返回响应式变量和生命周期函数
    return { count, state };
  },
};
```
2. 生命周期钩子
Vue 3 提供了一系列生命周期函数，通过 onXXX 的形式来使用，如 onMounted、onUpdated、onUnmounted 等。

常用生命周期钩子：
onBeforeMount: 在组件挂载之前调用。

onMounted: 在组件挂载后调用。

onBeforeUpdate: 在组件更新之前调用。

onUpdated: 在组件更新后调用。

onBeforeUnmount: 在组件卸载之前调用。

onUnmounted: 在组件卸载后调用。

使用方式：
 ```js
import { onMounted, onUnmounted } from 'vue';

export default {
  setup() {
    // 生命周期钩子
    onMounted(() => {
      console.log('Component mounted');
    });

    onUnmounted(() => {
      console.log('Component unmounted');
    });

    // ...
  },
};
```
3. 组件间通信
在 Vue 3 中，组件通信可以使用传统的 props 和 emit，也可以使用 provide 和 inject 进行跨层级通信。

使用 props 和 emit：
 ```vue
<template>
  <child :message="parentMessage" @update="handleUpdate" />
</template>

<script>
import { ref } from 'vue';
import Child from './Child.vue';

export default {
  components: {
    Child,
  },
  data() {
    return {
      parentMessage: 'Hello from Parent',
    };
  },
  methods: {
    handleUpdate(message) {
      console.log('Received message from Child:', message);
    },
  },
};
</script>
```
使用 provide 和 inject：
 ```vue
<template>
  <grand-child />
</template>

<script>
import { provide } from 'vue';
import GrandChild from './GrandChild.vue';

export default {
  components: {
    GrandChild,
  },
  setup() {
    provide('message', 'Hello from Parent');
  },
};
</script>
 ```

 ```vue
<template>
  <div>{{ message }}</div>
</template>

<script>
import { inject } from 'vue';

export default {
  setup() {
    const message = inject('message');
    console.log('Received message from Parent:', message);
    return { message };
  },
};
</script>
```
总结
在 Vue 3 中，组件通信的声明周期主要由 setup 函数和生命周期钩子来管理。通过 setup 函数可以声明响应式变量和设置生命周期函数，而生命周期钩子则提供了组件不同阶段的钩子函数，可以用于执行相应的操作。此外，组件间通信可以通过 props、emit、provide 和 inject 等方式来实现。这些特性使得 Vue 3 中的组件通信更加灵活和直观。

## 4. ssr性能优化相关有哪些
服务器端渲染（Server-Side Rendering，SSR）在提升性能和SEO方面有显著优势，但实现和优化一个高性能的SSR应用也需要注意许多细节。以下是一些SSR性能优化的关键策略：

1. 缓存策略
+ 页面缓存
缓存整个HTML页面，以减少服务器渲染次数。可以使用CDN或者反向代理（如Nginx）来缓存页面。

 ```js
// 使用Redis缓存
const redis = require('redis');
const client = redis.createClient();

app.get('*', (req, res) => {
  const key = `ssr:${req.url}`;
  client.get(key, (err, cachedPage) => {
    if (cachedPage) {
      res.send(cachedPage);
    } else {
      renderToString(req, (err, html) => {
        client.set(key, html, 'EX', 3600); // 缓存1小时
        res.send(html);
      });
    }
  });
});
```
+ 分片缓存
缓存页面的一部分，比如组件或者数据请求。

 ```js
// 缓存数据请求
const cacheMiddleware = (req, res, next) => {
  const key = `data:${req.url}`;
  client.get(key, (err, cachedData) => {
    if (cachedData) {
      res.json(JSON.parse(cachedData));
    } else {
      res.sendResponse = res.send;
      res.send = (body) => {
        client.set(key, body, 'EX', 3600); // 缓存1小时
        res.sendResponse(body);
      };
      next();
    }
  });
};

app.get('/api/data', cacheMiddleware, (req, res) => {
  // 数据请求逻辑
});
```
2. 组件级别的静态化

将不经常改变的组件预先渲染成静态HTML并缓存，减少动态渲染的开销。

3. 异步数据获取优化

尽量并行化数据请求，减少数据获取的时间。

 ```js
async function fetchDataForComponents(components, store) {
  return Promise.all(
    components.map(component => {
      if (component.asyncData) {
        return component.asyncData({ store });
      }
    })
  );
}

// 在路由处理时并行获取数据
router.beforeResolve((to, from, next) => {
  const matched = router.getMatchedComponents(to);
  const asyncDataHooks = matched.map(c => c.asyncData).filter(_ => _);
  if (!asyncDataHooks.length) {
    return next();
  }
  Promise.all(asyncDataHooks.map(hook => hook({ store, route: to })))
    .then(() => next())
    .catch(next);
});
```
4. 使用流式渲染

使用流式渲染（streaming）技术，可以逐步向客户端发送HTML，提高首屏加载速度。

 ```js
const { createBundleRenderer } = require('vue-server-renderer');
const renderer = createBundleRenderer(serverBundle, {
  runInNewContext: false,
  template,
  clientManifest
});

app.get('*', (req, res) => {
  const context = { url: req.url };
  res.setHeader('Content-Type', 'text/html');
  const stream = renderer.renderToStream(context);
  stream.pipe(res);
});
```
5. 减少客户端JavaScript体积

使用代码拆分和懒加载减少客户端需要加载的JavaScript体积。

 ```js
// 使用动态import实现懒加载
const Foo = () => import('./Foo.vue');

new VueRouter({
  routes: [
    { path: '/foo', component: Foo }
  ]
});
```
6. 预加载关键资源

利用`<link rel="preload">和<link rel="prefetch">`标签预加载关键资源，减少页面切换时的延迟。

 ```html
<link rel="preload" href="/static/js/main.js" as="script">
<link rel="preload" href="/static/css/main.css" as="style">
```
7. 服务端和客户端渲染结果一致

确保服务端和客户端渲染的结果一致，以避免不必要的DOM操作和样式抖动。

8. 性能监控与分析

使用性能监控工具如Google Lighthouse、New Relic或WebPageTest，持续监控和分析SSR性能，找出瓶颈并优化。

9. 优化服务器性能

确保服务器资源充足，合理配置CPU、内存、网络等资源，优化Node.js运行环境（如使用最新的LTS版本），使用集群模式（如PM2）来提升并发处理能力。

10. 代码优化

尽量减少不必要的计算和复杂度，优化算法和数据结构，减少阻塞操作。

通过以上策略，可以显著提升SSR应用的性能，提供更快的响应速度和更好的用户体验。

## 5. 前端性能指标LCP这个最大的内容底层是用什么算法计算的
Largest Contentful Paint（LCP，最大内容绘制）是衡量网页加载性能的关键指标之一，反映了页面在用户可视区域内最大可见内容元素的加载时间。LCP 的计算涉及一系列复杂的底层算法和技术，主要包括以下几个方面：

1. 内容元素的识别
浏览器需要识别页面上所有的内容元素，并判断哪些元素是用户可见的。LCP 关注的内容元素包括：

+ `<img>` 标签中的图片。
+ `<video>` 标签中的海报图像（poster）。
+ 包含背景图像的元素（通过 background-image CSS 属性定义的图像）。
+ `<svg>` 元素。
+ 块级元素或行内块级元素中的文本节点（如 `<div>、<p>、<h1>` 等）。

2. 元素的可见性计算

浏览器会计算每个内容元素的可见性。这包括确定元素是否在视口（viewport）内，是否被其他元素遮挡等。

3. 元素尺寸的计算

对于在视口内的内容元素，浏览器会计算其渲染尺寸（rendered size），并选择其中最大的元素作为候选。

4. 时间戳的捕获

+ 每个候选元素在首次绘制到屏幕时，浏览器会捕获其渲染时间戳。这包括以下几种情况：
+ 首次渲染图片、视频、SVG 等图像元素。
+ 首次渲染文本内容。
+ 图像加载完成后，重新绘制图像元素。

5. 选择最大内容元素

在页面加载过程中，浏览器持续监控所有内容元素的变化，并根据其可见性和尺寸，动态更新最大的内容元素及其渲染时间戳。

6. 最终LCP的确定

页面加载完成或在用户首次交互（如滚动、点击等）之后，浏览器会确定最终的 LCP 值，即最大的内容元素的渲染时间戳。

**LCP 计算的底层算法**

浏览器使用一系列复杂的算法和机制来实现上述步骤，以下是一些具体的实现细节：

+ 可见性算法

浏览器会利用布局引擎和渲染引擎的功能，结合视口的位置和尺寸，判断元素是否在视口内，并计算元素的可见区域。

+ 尺寸计算

通过浏览器的布局计算，确定元素的渲染尺寸。对于图片和视频，尺寸计算比较直接。对于文本内容，浏览器需要计算包含文本的块级元素的尺寸。

+ 时间戳捕获

利用性能计时 API（如 PerformanceObserver）捕获内容元素的渲染时间。PerformanceObserver 可以监听 largest-contentful-paint 条目，并通过回调函数获取相关时间戳。

 ```js
if ('PerformanceObserver' in window) {
  const observer = new PerformanceObserver((entryList) => {
    for (const entry of entryList.getEntries()) {
      console.log('LCP candidate:', entry);
    }
  });
  observer.observe({ type: 'largest-contentful-paint', buffered: true });
}
```
示例代码
以下是一个简单的示例代码，展示如何使用 PerformanceObserver 监听和获取 LCP 值：

 ```js
if ('PerformanceObserver' in window) {
  const observer = new PerformanceObserver((list) => {
    const entries = list.getEntries();
    const lastEntry = entries[entries.length - 1];
    console.log('Largest Contentful Paint:', lastEntry.startTime);
  });
  observer.observe({ type: 'largest-contentful-paint', buffered: true });

  window.addEventListener('load', () => {
    setTimeout(() => {
      observer.takeRecords();
      observer.disconnect();
    }, 5000); // 等待页面加载完成5秒后断开observer
  });
}
```
在这个示例中，PerformanceObserver 被用来监听 largest-contentful-paint 类型的性能条目，并在加载完成后获取并打印 LCP 的时间戳。

通过这些底层算法和机制，浏览器能够准确地计算和报告 LCP 值，帮助开发者优化网页的加载性能。

## 6. LCP FMP FCP为什么选择FCP作为衡量指标而不是其他指标
选择 FCP（First Contentful Paint，首次内容绘制）作为衡量指标有多个原因。尽管 LCP（Largest Contentful Paint，最大内容绘制）和 FMP（First Meaningful Paint，首次有意义绘制）也是非常重要的性能指标，但 FCP 在某些关键方面更适合作为衡量网页性能的标准。以下是详细的原因和解释：

1. 定义与易理解性
+ FCP：

定义：FCP 是指浏览器在开始渲染第一个由 DOM 内容渲染的内容（例如文本、图像、SVG 等）时的时间点。

易理解性：FCP 是用户第一次看到页面内容的时间，非常直观和易于理解。

+ LCP：

定义：LCP 是指页面中最大的内容元素（如大图、视频或大块文本）完全渲染完成的时间点。

复杂性：虽然 LCP 反映了页面中最重要内容的加载时间，但它的计算较为复杂，涉及对内容元素的识别和尺寸计算。

+ FMP：

定义：FMP 是指页面上主要内容第一次绘制完成的时间点。

不确定性：FMP 的定义和测量标准并不统一，且计算方法复杂，容易导致结果不一致。

2. 用户体验的关键时刻
FCP 直接反映了用户何时能看到页面内容，这个时间点非常关键，因为它标志着页面开始变得有意义。用户体验的研究表明，用户对页面的首次可见内容非常敏感，FCP 能较好地反映这一体验。

3. 测量和实现的简单性
FCP 易于测量和实现。浏览器通过性能 API 能够准确地捕捉到 FCP 事件，并且各大浏览器对 FCP 的实现和支持都比较一致，减少了跨浏览器的一致性问题。

4. 优化的指导性
FCP 提供了明确的优化目标。为了改善 FCP，开发者可以专注于减少首屏内容的阻塞资源、优化关键渲染路径、提高服务器响应速度等。这些优化措施也能间接提升其他性能指标（如 LCP 和 FMP）。

5. 标准化和广泛接受
FCP 已经被广泛接受为性能优化的重要指标，且被包括 Google 在内的多种性能评估工具（如 Lighthouse 和 Web Vitals）采用，形成了业界的标准。

6. 与其他指标的关系
虽然 LCP 和 FMP 也很重要，但它们更多是反映页面加载过程中的后续阶段。FCP 作为一个早期指标，可以快速反馈页面加载性能，帮助开发者在早期阶段进行优化。

总结
选择 FCP 作为衡量指标，是因为它直接反映了用户在页面加载过程中首次看到内容的时间点，这对用户体验至关重要。FCP 易于理解、测量和优化，为开发者提供了明确的优化方向，同时它也得到了广泛的标准化和应用。这些优势使得 FCP 成为评估网页性能的一个理想指标。

## 7. 虚拟列表item固定高度和不固定高度是怎么做的
虚拟列表是一种优化长列表渲染性能的技术，通过只渲染视口内的可见项来减少DOM节点数，从而提高渲染性能。虚拟列表可以处理固定高度和不固定高度的项，以下是实现两者的不同方法：

1. 固定高度的虚拟列表
对于固定高度的虚拟列表，每个项的高度是相同的，这样可以通过简单的数学计算来确定哪些项需要渲染。

实现步骤：
+ 确定每个项的高度：假设每个项的高度为itemHeight。
+ 计算可见项的数量：根据视口高度viewportHeight和项的高度itemHeight，计算出视口内可以容纳的最大项数。
+ 计算滚动偏移：根据滚动位置scrollTop，计算出第一个可见项的索引。
+ 渲染可见项：根据第一个可见项的索引和可见项的数量，只渲染这些项。

示例代码：
 ```js
import React, { useState, useRef, useEffect } from 'react';

const VirtualList = ({ itemCount, itemHeight, renderItem }) => {
  const [scrollTop, setScrollTop] = useState(0);
  const viewportRef = useRef(null);

  const viewportHeight = 500; // 假设视口高度为500px
  const totalHeight = itemCount * itemHeight;

  const startIndex = Math.floor(scrollTop / itemHeight);
  const endIndex = Math.min(itemCount - 1, Math.ceil((scrollTop + viewportHeight) / itemHeight) - 1);

  const visibleItems = [];
  for (let i = startIndex; i <= endIndex; i++) {
    visibleItems.push(
      <div key={i} style={{ position: 'absolute', top: i * itemHeight, height: itemHeight, width: '100%' }}>
        {renderItem(i)}
      </div>
    );
  }

  useEffect(() => {
    const handleScroll = (e) => {
      setScrollTop(e.target.scrollTop);
    };
    const viewport = viewportRef.current;
    viewport.addEventListener('scroll', handleScroll);
    return () => {
      viewport.removeEventListener('scroll', handleScroll);
    };
  }, []);

  return (
    <div ref={viewportRef} style={{ position: 'relative', height: viewportHeight, overflowY: 'auto' }}>
      <div style={{ height: totalHeight, position: 'relative' }}>
        {visibleItems}
      </div>
    </div>
  );
};
```

```js
// 使用示例
const App = () => {
  const itemCount = 1000;
  const itemHeight = 50;
  const renderItem = (index) => <div style={{ padding: 20 }}>Item {index}</div>;

  return <VirtualList itemCount={itemCount} itemHeight={itemHeight} renderItem={renderItem} />;
};

export default App;
```

2. 不固定高度的虚拟列表

对于不固定高度的虚拟列表，每个项的高度不同，需要使用更复杂的计算来确定哪些项需要渲染。可以采用以下方法：

实现步骤：
+ 动态测量项的高度：在初次渲染时，测量每个项的高度，并缓存这些高度。
+ 计算可见项的数量：根据视口高度和滚动位置，计算出哪些项是可见的。
+ 渲染可见项：根据可见项的索引，只渲染这些项，并将它们放置在正确的位置。

示例代码：
 ```js
import React, { useState, useRef, useEffect, useCallback } from 'react';

const VirtualList = ({ itemCount, renderItem }) => {
  const [scrollTop, setScrollTop] = useState(0);
  const [itemHeights, setItemHeights] = useState(new Array(itemCount).fill(0));
  const [totalHeight, setTotalHeight] = useState(0);
  const viewportRef = useRef(null);
  const itemRefs = useRef(new Array(itemCount).fill(null));

  const viewportHeight = 500; // 假设视口高度为500px

  // 动态测量项的高度
  const measureItems = useCallback(() => {
    const newItemHeights = itemRefs.current.map((item) => (item ? item.getBoundingClientRect().height : 0));
    setItemHeights(newItemHeights);
    setTotalHeight(newItemHeights.reduce((sum, height) => sum + height, 0));
  }, [itemCount]);

  useEffect(() => {
    measureItems();
  }, [measureItems]);

  const getVisibleRange = () => {
    let startIndex = 0;
    let offset = 0;

    while (offset + itemHeights[startIndex] < scrollTop) {
      offset += itemHeights[startIndex];
      startIndex += 1;
    }

    let endIndex = startIndex;
    offset = 0;

    while (offset < viewportHeight && endIndex < itemCount) {
      offset += itemHeights[endIndex];
      endIndex += 1;
    }

    return { startIndex, endIndex: Math.min(endIndex, itemCount - 1) };
  };

  const { startIndex, endIndex } = getVisibleRange();

  const visibleItems = [];
  let offset = 0;
  for (let i = 0; i < startIndex; i++) {
    offset += itemHeights[i];
  }
  for (let i = startIndex; i <= endIndex; i++) {
    visibleItems.push(
      <div
        key={i}
        ref={(el) => (itemRefs.current[i] = el)}
        style={{ position: 'absolute', top: offset, width: '100%' }}
      >
        {renderItem(i)}
      </div>
    );
    offset += itemHeights[i];
  }

  useEffect(() => {
    const handleScroll = (e) => {
      setScrollTop(e.target.scrollTop);
    };
    const viewport = viewportRef.current;
    viewport.addEventListener('scroll', handleScroll);
    return () => {
      viewport.removeEventListener('scroll', handleScroll);
    };
  }, []);

  return (
    <div ref={viewportRef} style={{ position: 'relative', height: viewportHeight, overflowY: 'auto' }}>
      <div style={{ height: totalHeight, position: 'relative' }}>
        {visibleItems}
      </div>
    </div>
  );
};
```
```js
// 使用示例
const App = () => {
  const itemCount = 1000;
  const renderItem = (index) => <div style={{ padding: 20 }}>Item {index}</div>;

  return <VirtualList itemCount={itemCount} renderItem={renderItem} />;
};

export default App;

```
关键点解释

+ 固定高度：由于所有项的高度固定，计算哪些项可见非常简单，只需根据视口高度和项高度进行简单的数学计算。

+ 不固定高度：需要动态测量每个项的高度，并根据滚动位置计算可见项的范围，这需要更多的计算和缓存。

以上两种方法都可以有效地优化长列表的渲染性能，但根据具体应用场景选择合适的方法非常重要。固定高度的虚拟列表实现较为简单，性能较好；而不固定高度的虚拟列表实现更为复杂，但灵活性更高。

## 8. tree shaking 底层是怎么实现的
> Tree shaking 是一种用于删除 JavaScript 中未使用代码的技术，通常应用于现代模块打包工具（如 Webpack、Rollup 等）以优化打包结果，减小最终输出的文件体积。其核心是依赖静态分析技术，通过分析代码的依赖关系，去除那些从未被使用的代码。

Tree Shaking 的核心原理

1. Tree shaking 的核心原理主要依赖于以下几方面：

ES6 模块语法：

ES6 模块系统（import 和 export）是静态的，可以在编译时进行静态分析。这与 CommonJS（require 和 module.exports）不同，后者的动态特性使得静态分析更加困难。

静态分析：

  + 静态分析代码，构建模块之间的依赖关系图（dependency graph）。
  + 通过分析哪些模块和导出的成员被实际使用（引用），确定哪些是“树”的可达部分。
  + 移除依赖关系图中不可达的代码。

实现细节

以 Webpack 和 Rollup 为例，具体的实现细节如下：

**Webpack**

1. 解析和构建依赖图：
    + Webpack 从入口文件开始，递归解析所有模块和依赖，构建一个模块依赖图。
    + 通过 Babel 等工具，将 ES6 模块转换为 Webpack 可识别的模块格式。

2. 标记和摇树：

    + Webpack 的 TerserPlugin（默认压缩插件）在压缩阶段进行 tree shaking。
    + 通过解析 AST（抽象语法树），标记所有被使用的导出。
    + 移除未被使用的导出代码。

3. 输出优化：

   + 通过 sideEffects 属性，进一步优化模块。如果一个模块或文件被标记为无副作用（sideEffects: false），Webpack 可以大胆地移除未使用的导入。

**Rollup**

1. 模块分析：

    + Rollup 直接使用 ES6 模块语法，解析并构建模块依赖图。
    + 通过递归分析导入和导出，确定哪些模块和导出是未被使用的。

2. 标记和移除：

    + Rollup 通过标记那些被引用的导出，移除未引用的导出。
    + 生成优化后的输出代码，只包含被使用的代码部分。

3. 摇树优化：

  + Rollup 更加专注于纯净的 ES6 模块环境，结合其内部的静态分析算法，有效地移除未使用的代码。

Tree Shaking 实现示例
下面是一个简单的 Tree Shaking 实现示例，展示了如何在 Webpack 和 Rollup 中使用 tree shaking。

Webpack 配置 项目结构：
```js
 
src/
  - index.js
  - utils.js
webpack.config.js
src/utils.js：

 
export const usedFunction = () => {
  console.log('This function is used');
};

export const unusedFunction = () => {
  console.log('This function is unused');
};
src/index.js：

 
import { usedFunction } from './utils';

usedFunction();
webpack.config.js：

 
const path = require('path');

module.exports = {
  mode: 'production',
  entry: './src/index.js',
  output: {
    filename: 'bundle.js',
    path: path.resolve(__dirname, 'dist'),
  },
  optimization: {
    usedExports: true, // 启用 tree shaking
  },
  module: {
    rules: [
      {
        test: /\.js$/,
        exclude: /node_modules/,
        use: {
          loader: 'babel-loader',
          options: {
            presets: ['@babel/preset-env'],
          },
        },
      },
    ],
  },
};
```
Rollup 配置
项目结构：

 ```js
src/
  - index.js
  - utils.js
rollup.config.js
src/utils.js：

 
export const usedFunction = () => {
  console.log('This function is used');
};

export const unusedFunction = () => {
  console.log('This function is unused');
};
src/index.js：

 
import { usedFunction } from './utils';

usedFunction();
rollup.config.js：

 
import { terser } from 'rollup-plugin-terser';

export default {
  input: 'src/index.js',
  output: {
    file: 'dist/bundle.js',
    format: 'es',
  },
  plugins: [terser()],
};
```
结论
Tree shaking 通过静态分析代码依赖关系，移除未使用的代码，优化了打包结果。借助于 ES6 模块的静态特性，工具如 Webpack 和 Rollup 能够有效地实现这一过程，从而提高前端应用的性能和加载速度。在实际项目中，结合 sideEffects 属性和合理的代码结构，可以进一步提升 tree shaking 的效果。

## 9. 前端和客户端交互底层是怎么实现的
前端和客户端交互的底层实现主要依赖于网络通信协议和浏览器内的机制。这里我们将详细探讨这些技术和机制，包括 HTTP/HTTPS 请求、WebSocket、WebRTC 以及浏览器提供的 API 等。

1. HTTP/HTTPS 请求
HTTP（HyperText Transfer Protocol）和 HTTPS（HTTP Secure）是前端和后端进行通信的最常见方式。

基本流程
DNS 解析：浏览器将域名解析为服务器的 IP 地址。

TCP 连接：通过 TCP（三次握手）与服务器建立连接。如果是 HTTPS，还会进行 TLS 握手以建立加密连接。

发送请求：浏览器构造并发送 HTTP/HTTPS 请求报文。

服务器处理请求：服务器处理请求并返回响应报文。

接收响应：浏览器接收响应并解析数据，更新页面或执行相应逻辑。

底层细节
TCP/IP 协议：HTTP/HTTPS 基于 TCP/IP 协议栈。TCP 负责确保数据包的可靠传输和顺序，IP 负责路由和寻址。

TLS/SSL 协议：HTTPS 使用 TLS/SSL 协议进行加密，确保数据传输的安全性。

示例代码
 ```js
// 使用 fetch API 进行 HTTP 请求
fetch('https://api.example.com/data')
  .then(response => response.json())
  .then(data => console.log(data))
  .catch(error => console.error('Error:', error));

  ```
2. WebSocket
WebSocket 是一种全双工通信协议，允许客户端和服务器之间进行实时通信。

基本流程
建立连接：客户端向服务器发送 WebSocket 握手请求。

握手成功：服务器接受握手，升级 HTTP 连接为 WebSocket 连接。

双向通信：客户端和服务器可以相互发送消息，保持连接打开。

关闭连接：任一方可以关闭连接，结束通信。

底层细节
基于 TCP：WebSocket 基于 TCP 连接，具有较低的延迟。

协议升级：通过 HTTP 协议的 101 状态码升级为 WebSocket 协议。

示例代码
 ```js
// 创建 WebSocket 连接
const socket = new WebSocket('wss://example.com/socket');

// 连接打开事件
socket.addEventListener('open', (event) => {
  console.log('WebSocket is open now.');
  socket.send('Hello Server!');
});

// 收到消息事件
socket.addEventListener('message', (event) => {
  console.log('Message from server ', event.data);
});

// 连接关闭事件
socket.addEventListener('close', (event) => {
  console.log('WebSocket is closed now.');
});
```
3. WebRTC
WebRTC（Web Real-Time Communication）允许在浏览器之间直接进行音视频和数据传输。

基本流程
信令：通过现有的通信渠道（如 WebSocket）交换会话描述协议（SDP）和 ICE 候选者。

建立连接：使用 SDP 和 ICE 候选者进行 P2P 连接。

传输数据：通过 P2P 连接传输音视频流和数据。

关闭连接：任一方可以关闭连接，结束通信。

底层细节
P2P 连接：通过 NAT 打洞技术实现浏览器之间的直接连接。

多媒体处理：使用 RTP/RTCP 协议进行音视频数据传输。

数据通道：使用 SCTP 协议传输任意数据。

示例代码
 ```js
const pc = new RTCPeerConnection();

// 添加本地媒体流
navigator.mediaDevices.getUserMedia({ video: true, audio: true })
  .then(stream => {
    stream.getTracks().forEach(track => pc.addTrack(track, stream));
  });

pc.onicecandidate = (event) => {
  if (event.candidate) {
    // 发送 ICE 候选者给远端
    sendIceCandidateToRemote(event.candidate);
  }
};

pc.ontrack = (event) => {
  // 显示远端视频流
  const remoteVideo = document.getElementById('remoteVideo');
  remoteVideo.srcObject = event.streams[0];
};

// 通过信令服务器交换 SDP
function createOffer() {
  pc.createOffer().then(offer => {
    pc.setLocalDescription(offer);
    sendOfferToRemote(offer);
  });
}

function handleAnswer(answer) {
  pc.setRemoteDescription(answer);
}
```
4. 浏览器 API
浏览器提供了一些 API，简化前端和客户端之间的交互：

Fetch API：用于发起网络请求，替代 XMLHttpRequest。

Service Workers：拦截网络请求，实现离线缓存和推送通知。

IndexedDB：本地存储大型结构化数据。

示例代码（Service Worker）
 ```js
// 注册 Service Worker
navigator.serviceWorker.register('/service-worker.js');

// 在 service-worker.js 中拦截请求并缓存
self.addEventListener('fetch', (event) => {
  event.respondWith(
    caches.match(event.request)
      .then(response => {
        if (response) {
          return response; // 从缓存返回
        }
        return fetch(event.request); // 发起网络请求
      })
  );
});
```
总结
前端和客户端交互通过多种技术和协议实现，从传统的 HTTP/HTTPS 请求到实时通信的 WebSocket 和 WebRTC。这些技术各有其应用场景和优势，结合使用可以构建高效、灵活和实时的前端应用。在实际开发中，根据具体需求选择合适的通信方式和技术栈，优化用户体验和应用性能。

## 10.createWebhistory 和 createwebhashhistory 的区别
> 在Vue.js中，Vue Router是非常重要的路由管理工具，它提供了多种路由模式来满足不同的需求。其中，createWebHistory和createWebHashHistory是两种常用的路由模式，它们在URL的处理方式上有着显著的区别。

1. createWebHistory

**原理**： createWebHistory使用HTML5 History API来管理路由，它通过浏览器的History API来改变URL，实现路由的跳转和管理。在使用createWebHistory时，URL中的路由信息是以正常的路径形式呈现，不带有#号。

**应用场景**：

+ 适用于支持HTML5 History API的现代浏览器，如Chrome、Firefox、Safari等。
+ 适用于需要更加友好的URL形式，不带有#号，更符合用户的预期和习惯。
+ 适用于需要利用浏览器的前进和后退按钮进行导航的场景。

**优点**：

+ URL更加美观，不带有#号，提升了用户体验。
+ 支持HTML5 History API，能够利用浏览器的前进和后退按钮进行导航。

**缺点**：

+ 不兼容低版本的浏览器，需要特殊处理。
+ 在部署时需要服务器端的配置支持，以避免刷新页面时出现404错误。

2. createWebHashHistory

**原理**： createWebHashHistory使用浏览器的URL的哈希（#）部分来管理路由，它通过监听浏览器的hashchange事件来实现路由的跳转和管理。在使用createWebHashHistory时，URL中的路由信息是以哈希（#）的形式呈现。

**应用场景**：

+ 适用于兼容性要求较高的场景，哈希模式在大多数浏览器中都能正常工作。
+ 适用于不支持HTML5 History API的浏览器，如IE9及以下版本。

**优点**：

+ 兼容性较好，适用于大多数现代浏览器以及不支持HTML5 History API的旧版本浏览器。
+ 不需要服务器端的特殊配置，可以直接部署上线。

**缺点**：

+ URL带有#号，不够美观，可能会影响用户体验。
+ 无法利用浏览器的前进和后退按钮进行导航，需要自行实现路由的导航逻辑。

**结论**

`createWebHistory`和`createWebHashHistory`是`Vue Router`提供的两种常用的路由模式，它们在URL的处理方式上有着显著的区别。
+ createWebHistory使用HTML5 History API来管理路由，URL中不带有#号，适用于现代浏览器；
+ 而createWebHashHistory使用URL的哈希部分来管理路由，URL中带有#号，兼容性较好，适用于不支持HTML5 History API的浏览器。

在实际开发中，根据项目的需求和目标浏览器的兼容性要求，合理选择适当的路由模式非常重要。如果项目不需要考虑兼容性问题，并且希望URL更加友好美观，可以选择createWebHistory；如果项目需要兼容性较好，并且不介意URL中带有#号，可以选择createWebHashHistory。

深入理解createWebHistory和createWebHashHistory的原理和应用场景，可以帮助我们更好地选择合适的路由模式，提升Vue.js应用的开发效率和用户体验。

## 11. 什么是 MVVM？比之 MVC 有什么区别？
MVVM（Model-View-ViewModel）和 MVC（Model-View-Controller）都是软件设计模式，用于组织和架构应用程序的代码。它们之间的主要区别在于如何组织和管理用户界面的代码。

a. **MVC**（Model-View-Controller）：

+ Model（模型）： 负责应用程序的数据和业务逻辑。它表示应用程序的状态和行为，与数据库通信以检索或更新数据。
+ View（视图）： 负责显示数据和用户界面元素。它接收来自控制器的数据，并将其渲染成用户界面。
+ Controller（控制器）： 负责处理用户输入、更新模型和调整视图。它充当用户界面和应用程序逻辑之间的协调者。
+ 在传统的 MVC 模式中，View 和 Controller 之间的关系是相对紧密的，Controller 负责管理用户输入并更新 Model，同时直接影响 View。

b. **MVVM**（Model-View-ViewModel）：
+ Model（模型）： 负责应用程序的数据和业务逻辑，与 MVC 中的 Model 类似。
+ View（视图）： 负责显示数据和用户界面元素，与 MVC 中的 View 类似。
+ ViewModel（视图模型）： 介于 View 和 Model 之间，负责处理用户输入、与 Model 交互，并为 View 提供渲染所需的数据。ViewModel 是一个用于封装视图状态和行为的抽象层。
+ 在 MVVM 中，View 和 ViewModel 是通过数据绑定关联的，ViewModel 通常会包含一个或多个属性，这些属性与 View 中的元素绑定。当 ViewModel 的属性变化时，View 会自动更新，而用户的操作也会直接影响到 ViewModel 中的数据。

**区别**：

+ 数据绑定： MVVM 强调数据绑定，通过双向绑定实现视图和数据的同步。MVC 中，视图和控制器之间的关系通常是单向的。
+ 视图模型： MVVM 引入了 ViewModel，它是一个专门用于管理视图状态和行为的组件。MVC 中，控制器负责处理用户输入和更新模型，直接影响视图。
+ 松散耦合： MVVM 中的各个组件之间相对较为松散耦合，每个组件都有明确定义的职责。MVC 中，视图和控制器之间的联系相对较紧密。

总体而言，MVVM 强调数据驱动视图，通过数据绑定实现自动更新，而 MVC 强调用户输入驱动视图，通过控制器更新视图。 MVVM 的数据绑定使得前端开发更加简洁和高效，特别适用于大规模的前端应用。

## 12. Vue 和 React 之间的区别
Vue.js 和 React 都是流行的前端 JavaScript 框架，用于构建用户界面。以下是它们之间的一些主要区别：

a. **设计理念和开发范式**：
组件化：
 + Vue： Vue.js 将组件化作为其核心思想，提供了更直观和灵活的组件系统。单文件组件（SFC）是一种将模板、样式和脚本封装在一个文件中的方式。
 + React： React 也支持组件化，但它更加强调的是一切皆是组件的思想。React 组件使用 JSX 语法，将模板和逻辑紧密结合在一起。

b. **数据绑定**：
双向数据绑定：
+ Vue： Vue 提供了简单的双向数据绑定，通过 v-model 指令可以轻松实现表单元素和数据的双向绑定。
+ React： React 采用的是单向数据流，通过状态（state）和属性（props）来管理数据流向。

c. **模板语法**：
模板语法：
+ Vue： Vue 使用模板语法，模板中可以包含直接渲染的 HTML 代码。Vue 的模板更接近传统的 HTML 结构。
+ React： React 使用 JSX 语法，它是一种在 JavaScript 中嵌套 XML 结构的语法。这使得模板和逻辑更紧密地结合在一起，但也需要习惯这种嵌套结构。

d. **学习曲线**：
学习曲线：
+ Vue： Vue 被认为是相对容易学习的框架，尤其适合初学者。其文档清晰，API 直观，上手较快。
+ React： React 在一开始可能对新手有一定的学习曲线，尤其是对于 JSX 语法和一些概念的理解。但一旦掌握，React 提供了强大的灵活性。

e. **生态系统和社区**：
生态系统：
+ Vue： Vue 的生态系统相对较小，但也在不断壮大。它有一些优秀的插件和工具，但相比 React，生态规模较小。
+ React： React 拥有更大的生态系统和庞大的社区支持。有丰富的第三方库和组件，适用于各种应用场景。

f. **状态管理**：
状态管理：
+ Vue： Vue 提供了 Vuex 作为官方的状态管理库，用于管理组件之间的共享状态。
+ React： React 可以使用 Context API 和第三方库（如 Redux）来进行状态管理。

g. **组件通信**：
组件通信：
+ Vue： Vue 提供了 props 和自定义事件等机制来实现组件之间的通信。
+ React： React 通过 props 和回调函数来传递数据，同时也可以使用 Context API 或 Redux 等进行全局状态管理。

h. **社区和企业应用**：
应用场景：
+ Vue： Vue 在中小型项目和单页面应用中表现良好，也适用于快速原型开发。
+ React： React 更常用于大型和复杂的项目，且在大型企业应用中更为普遍。

总体而言，Vue 和 React 都是强大的前端框架，选择其中之一通常取决于项目的需求、团队的经验和开发者的偏好。

## 13. Vue2，3 的区别
Vue 2 和 Vue 3 之间有一些显著的区别。以下是它们的一些主要区别：

+ **性能优化**： Vue 3 在性能方面有显著的改进。它引入了响应式系统的重写，使用 Proxy 替代 Object.defineProperty，这使得 Vue 3 的性能比 Vue 2 更好。
+ **Composition API**： Vue 3 引入了 Composition API，这是一个新的组织组件逻辑的方式。相比于 Vue 2 的选项 API，Composition API 更灵活，更容易组织和重用代码。
+  **Teleport**： Vue 3 引入了 Teleport 特性，允许你在 DOM 中的任何位置渲染组件的内容。这对于在应用程序中移动组件的位置或在不同的层次结构中渲染组件很有用。
+ **新的特性和改进**： Vue 3 引入了一些新的特性，如 Fragments（片段）、Custom Directives（自定义指令）等，并对一些现有特性进行了改进。这使得开发者在构建复杂应用时更加方便。
+ **Tree-shaking 支持**： Vue 3 更好地支持 tree-shaking，这意味着在构建时可以更有效地剔除未使用的代码，从而减小应用程序的体积。
+ **TypeScript 集成**： Vue 3 对 TypeScript 的支持更加紧密和友好，包括完全的 TypeScript 类型定义。

这些只是一些主要的区别，具体取决于你的项目需求和个人偏好。如果你已经使用 Vue 2，迁移到 Vue 3 可能需要一些时间，但从性能和开发体验的角度来看，它可能是值得的。

## 14. Vue3 性能更好在哪里
Vue 3 相对于 Vue 2 在性能方面有一些改进，主要体现在以下几个方面：

+ **Proxy 替代 Object.defineProperty**： Vue 3 中的响应式系统采用 Proxy 替代了 Vue 2 中使用的 Object.defineProperty。Proxy 允许更细粒度的拦截操作，这使得 Vue 3 能够更高效地追踪属性的变化，提高了响应式系统的性能。
+ **编译器优化**： Vue 3 的编译器经过优化，生成的代码更加精简和高效。这有助于减小应用程序的体积并提高运行时的性能。
+ **静态树提升**（Static Tree Hoisting）： Vue 3 引入了静态树提升的概念，可以将一些静态节点在渲染时提升为常量，减少不必要的重复渲染，从而提高性能。
+ **优化的事件处理**： Vue 3 对事件处理进行了优化，使其更加高效。特别是对于频繁触发的事件，Vue 3 的性能相对更好。
+ **Teleport 特性的引入**： Vue 3 的 Teleport 特性允许在 DOM 中的任何位置渲染组件的内容，这在性能优化方面提供了更多的灵活性，能够更高效地处理组件的渲染和移动。
+ **Tree-shaking 支持**： Vue 3 更好地支持 tree-shaking，使得在构建时可以更有效地剔除未使用的代码，减小应用程序的体积，从而提高加载和运行时的性能。

总体而言，这些改进和优化使得 Vue 3 在性能方面相对于 Vue 2 有所提升，特别是在处理大型和复杂的应用程序时。

## 15. Vue2，3 diff 算法原理
Vue 2 和 Vue 3 在数据响应方面采用了不同的 diff 算法，用于比较虚拟 DOM 树并更新视图。以下是 Vue 2 和 Vue 3 的 diff 算法原理的概述：

a. **Vue 2 的 Diff 算法**：

Vue 2 使用的是经典的Virtual DOM和基于深度优先的双端比较的算法。它的主要步骤如下：

+ 创建虚拟 DOM 树： 将组件的状态映射到虚拟 DOM 树，这是一个 JavaScript 对象表示的抽象层次结构。
+ 渲染为真实 DOM： 将虚拟 DOM 树渲染为真实 DOM。
+ 数据变更时的 Diff： 当组件状态变化时，生成新的虚拟 DOM 树，然后和之前的虚拟 DOM 树进行比较。
+ 差异计算： 通过深度优先的算法，逐层比较新旧虚拟 DOM 树，找到两者之间的差异。
+ 更新： 根据差异，只对需要更新的部分进行实际 DOM 操作，最小化了对真实 DOM 的修改，提高了性能。

Vue 2 使用的是经典的 Virtual DOM 和基于深度优先的双端比较的 diff 算法。下面是 Vue 2 中 diff 算法的一般步骤：

+ 创建虚拟 DOM 树（Virtual DOM Tree）： 当组件的状态发生变化时，Vue 2 会首先根据新的状态生成一个新的虚拟 DOM 树。
+ 比较新旧虚拟 DOM 树： Vue 2 通过逐层比较新旧虚拟 DOM 树的节点，找出两者之间的差异。这一步是通过深度优先的算法实现的。
+ 生成差异（Diff）： 在比较过程中，当发现节点有差异时，Vue 2 会生成一个差异对象，该对象描述了如何更新真实 DOM 以保持与虚拟 DOM 的一致性。
+ 应用差异（Patch）： Vue 2 将生成的差异对象应用到真实 DOM 上，从而更新视图。这一步是通过对真实 DOM 进行相应的操作，比如修改节点的属性、插入新节点、删除不需要的节点等来实现的。
+ 更新组件状态： 最后，Vue 2 会更新组件的状态，确保虚拟 DOM 和组件的状态保持同步。

在这个过程中，Vue 2 采用了一些优化措施，例如通过限制比较的深度，只对同一层级的节点进行比较，以减小比较的范围。同时，对于列表渲染，Vue 2 采用了一种叫做“key”的机制，通过给列表中的元素添加唯一的标识符，可以帮助 Vue 更准确地追踪列表中元素的变化。

总体而言，Vue 2 的 diff 算法是一个高效的、基于 Virtual DOM 的算法，可以有效地减小对真实 DOM 的操作，提高视图更新的性能。然而，它并不是完美的，特别是在处理大型列表时，一些额外的优化措施可能是必要的。

b. **Vue 3 的 Diff 算法**：
Vue 3 引入了基于 Proxy 的响应式系统，同时也对 diff 算法进行了优化。其主要变化有：

+ Proxy 响应式系统： Vue 3 使用 Proxy 替代 Object.defineProperty 来实现响应式系统。Proxy 提供了更细粒度的拦截能力，使得 Vue 3 能够更精确地追踪属性的变化。
+ 静态树提升： Vue 3 引入了静态树提升的概念，通过提升静态节点，可以减少比较的复杂性，提高 diff 算法的效率。
+ Patch Flag： Vue 3 使用 Patch Flag 来标记需要更新的节点类型，从而减小比较的范围，提高了性能。
+ 缓存节点： Vue 3 在 diff 过程中对一些中间结果进行缓存，避免不必要的重复计算，提高了性能。

总体而言，Vue 3 的 diff 算法在基于 Proxy 的响应式系统和一些优化手段的支持下，相对于 Vue 2 在性能方面有所提升。这些优化使得 Vue 3 更高效地处理组件状态变更并更新视图。

Vue 3 的 diff 算法相对于 Vue 2 有一些改进，采用了一种称为“优化的渲染器”（Optimized Renderer）的策略。以下是 Vue 3 中 diff 算法的一般步骤：

+ 生成虚拟 DOM（Virtual DOM）： 当组件的状态发生变化时，Vue 3 会生成一个新的虚拟 DOM 树，该树表示组件的当前状态。
+ 计算新旧虚拟 DOM 之间的差异： Vue 3 使用 Patch Flag 机制，通过在虚拟 DOM 节点上标记一些信息，例如节点的静态性、是否有子节点等，来帮助 diff 算法更快速地找到差异。这使得 + Vue 3 在比较新旧虚拟 DOM 时能够更高效地确定需要更新的节点。
+ 生成差异（Diff）： 在比较过程中，Vue 3 生成一个差异对象，描述了需要对真实 DOM 进行的操作，如添加、移动、删除节点等。Vue 3 放弃了双端比较，采用的是更为高效的单端比较。
+ 应用差异（Patch）： Vue 3 将生成的差异对象应用到真实 DOM 上，通过对真实 DOM 进行相应的操作，更新视图。与 Vue 2 不同，Vue 3 的渲染器对 DOM 操作进行了优化，采用了更高效的算法，如可选的静态树提升等。
+ 更新组件状态： 最后，Vue 3 更新组件的状态，确保虚拟 DOM 和组件的状态保持同步。

Vue 3 引入了一些新的概念和优化，如 Patch Flag、静态树提升等，以提高 diff 算法的性能。总体而言，Vue 3 的 diff 算法在性能上有一些提升，尤其是在处理大型组件和复杂视图时。


## 16. Vue v-for 的 key 值是什么，没有唯一性的 key 值怎么办
在 Vue 中，key 是用于识别 v-for 循环中的每个节点的特殊属性。它的作用是帮助 Vue 识别每个节点的身份，从而在列表发生变化时更高效地更新 DOM。key 应该具有唯一性，即在同一列表中，key 的值不能重复。
```vue
<div v-for="(item, index) in items" :key="item.id">
  {{ item.name }}
</div>
```
在上面的例子中，item.id 被用作 key，假设 item.id 具有唯一性，这有助于 Vue 在更新列表时更准确地识别每个节点。

如果数据中没有唯一标识符可供用作 key，可以使用索引作为 key。但要注意，最好在有唯一标识符的情况下使用唯一标识符，因为使用索引作为 key 有时可能引发一些问题，特别是在列表项的顺序发生变化时。
```vue
<div v-for="(item, index) in items" :key="index">
  {{ item.name }}
</div>
```
如果列表项没有唯一标识符且不适合使用索引，可以考虑使用 v-for 的特殊语法，直接迭代对象的值而不是索引。这样，Vue 将使用对象的属性名作为 key。
```vue
<div v-for="item in items" :key="item.id">
  {{ item.name }}
</div>
```
在任何情况下，尽量确保 key 具有唯一性，以确保 Vue 在处理列表时能够正确追踪和更新节点。

## 17.Generator 打印了什么

Generator 函数是 ES6 引入的一种新型函数，它通过 function* 关键字定义。Generator 函数可以被看作是可以暂停和继续执行的函数。在执行 Generator 函数时，通过调用其 next 方法，可以逐步执行 Generator 函数体内的代码。

让我们逐步分析你提供的代码：
```js
function* test(x) {
 const y = 2 * (yield (x + 1))
 const z = yield (y / 3)
 console.log('x', x, 'y', y, 'z', z)
 return x + y + z
}

const b = test(5)
console.log(b.next())   // { value: 6, done: false }
console.log(b.next(12)) // { value: 8, done: false }
console.log(b.next(13)) // x 5 y 24 z 13 { value: 18, done: true }
```
+ 第一次调用 `b.next()`：
`Generator` 函数开始执行，执行到 `yield (x + 1)` 时暂停，返回 `{ value: 6, done: false }`。此时 yield 的表达式的值为 `x + 1`，即 `5 + 1`。
+ 第二次调用 `b.next(12)`：
继续执行 `Generator` 函数，将传入的参数 `12` 赋给上一个 `yield` 表达式的结果。执行到 `yield (y / 3)` 时暂停，返回 `{ value: 8, done: false }`。此时 y 的值为` 2 * 12`，即 `24`。
+ 第三次调用 `b.next(13)`：
继续执行 `Generator` 函数，将传入的参数 `13` 赋给上一个 `yield` 表达式的结果。执行到函数末尾，即 `console.log` 语句，打印 `'x 5 y 24 z 13'`。最终返回 `{ value: 18, done: true }`，表示 `Generator` 函数执行完毕。

注意：

+ 第一次调用 `next` 时传入的参数并不会被使用，因为第一次调用主要用于启动生成器。
+ 每次调用 `next` 时，传入的参数将会成为上一个 yield 表达式的结果，即它将影响到 `Generator` 函数中的赋值语句。

## 18 promise.all()

```js
function customPromiseAll(promises) {
  return new Promise((resolve, reject) => {
    // 先判断是否为数组
    if (!Array.isArray(promises)) {
      reject(new TypeError('Promises must be an array'));
    }

    const results = [];
    let completedCount = 0;

    const handleCompletion = (index, result) => {
      results[index] = result;
      completedCount++;

      if (completedCount === promises.length) {
        resolve(results);
      }
    };

    for (let i = 0; i < promises.length; i++) {
      Promise.resolve(promises[i])
        .then((result) => {
          handleCompletion(i, result);
        })
        .catch((error) => {
          reject(error);
        });
    }

    if (promises.length === 0) {
      resolve(results);
    }
  });
}

// 示例用法
const promise1 = Promise.resolve(1);
const promise2 = Promise.resolve(2);
const promise3 = Promise.resolve(3);

customPromiseAll([promise1, promise2, promise3])
  .then((results) => {
    console.log('All promises resolved:', results);
  })
  .catch((error) => {
    console.error('One or more promises rejected:', error);
  });


```

> 这个实现会返回一个新的 Promise，该 Promise 在所有传入的 Promise 都成功时将解析为一个数组，包含每个 Promise 的结果。如果其中任何一个 Promise 被拒绝，它会立即将新的 Promise 拒绝，并传递拒绝的原因。请注意，此实现仅处理 Promise 对象，并且不支持其他可迭代对象。在实际应用中，可能需要更多的边界检查和错误处理。

## 19 require 和 import 的区别

在 JavaScript 和 TypeScript 中，`require` 和 `import` 是两种用于引入模块的方式。它们之间有一些显著的区别，主要体现在语法、使用环境和功能特性上。

#### 1. `require`

`require` 是 Node.js 中的模块加载方式，基于 CommonJS 模块规范。

###### 特点

- **语法**：`const module = require('module');`
- **同步加载**：`require` 是同步的，在执行到 `require` 语句时，模块会被立即加载和执行。
- **运行时加载**：模块在代码运行时被动态加载。
- **适用范围**：主要用于 Node.js 环境，但在某些打包工具（如 Browserify）中也可以用于前端。
- **动态加载**：可以在代码的任意位置使用 `require` 语句。

###### 示例

```javascript
const fs = require('fs');

fs.readFile('example.txt', 'utf8', (err, data) => {
  if (err) throw err;
  console.log(data);
});
```

#### 2. `import`

`import` 是 ES6（ECMAScript 2015）引入的模块加载方式，基于 ES 模块规范。

###### 特点

- **语法**：
  - 引入整个模块：`import * as module from 'module';`
  - 引入部分导出：`import { export1, export2 } from 'module';`
  - 默认导出：`import defaultExport from 'module';`
- **静态加载**：`import` 是静态的，模块在编译时被解析和加载。
- **块级作用域**：`import` 语句必须位于模块的顶层作用域，不允许在条件语句或函数中使用。
- **适用范围**：适用于浏览器环境和 Node.js（在启用了 ES 模块支持的情况下，通常需要将文件扩展名设为 `.mjs` 或在 `package.json` 中设置 `"type": "module"`）。
- **支持 Tree Shaking**：由于静态分析的特性，编译器可以在打包过程中进行 Tree Shaking，移除未使用的代码。

###### 示例

```javascript
import fs from 'fs';

fs.readFile('example.txt', 'utf8', (err, data) => {
  if (err) throw err;
  console.log(data);
});
```

#### 比较

| 特性                 | `require`                        | `import`                           |
|----------------------|----------------------------------|------------------------------------|
| 规范                 | CommonJS                         | ES6 模块                           |
| 语法                 | `const module = require('module');` | `import { something } from 'module';` |
| 加载方式             | 同步                             | 异步（静态解析）                   |
| 使用环境             | Node.js                          | 浏览器和 Node.js（ESM 支持）       |
| 动态加载             | 支持                             | 不支持                             |
| 适用范围             | 任意代码位置                     | 只能在顶层作用域                   |
| Tree Shaking 支持    | 不支持                           | 支持                               |

#### 选择使用

- **Node.js 环境**：
  - 使用 `require`，特别是在需要动态加载模块或兼容性需求时。
  - 使用 `import`，如果使用的是 ES 模块并且 Node.js 版本支持（如 v12+ 版本）。

- **前端开发**：
  - 使用 `import`，因为现代浏览器和工具链（如 Webpack、Babel）对 ES 模块有更好的支持和优化。

总结来说，`import` 是未来的趋势，更适合现代 JavaScript 开发，特别是在前端。而 `require` 依然是 Node.js 传统的模块加载方式，在需要兼容老旧环境或进行动态模块加载时仍然非常有用。

## 20 async 和 await的设计实现

> async 和 await 是 JavaScript 中用于处理异步操作的关键字，它们基于 Promise，提供了一种更直观和简洁的方式来编写异步代码。

#### 设计理念
  + 简化异步代码：async 和 await 通过使用同步风格的代码来处理异步操作，使代码更易于理解和维护，避免了传统回调地狱的问题。
  + 基于 Promise：它们是对 Promise 的语法糖，提供了一种更简洁的方式来处理 Promise，而不需要显式地使用 then 和 catch。

#### 实现原理

  ###### async 函数的执行：

  + async 函数会返回一个 Promise 对象。
  + 函数内部的所有代码会被包装在一个生成器函数中，当函数被调用时，生成器会立即执行，直到第一个 await 表达式。

  ###### await 的执行：

  + 当执行到 await 关键字时，函数的执行会被暂停，等待 await 后面的 Promise 完成。
  + await 表达式会返回 Promise 的解析值。
  + 如果 Promise 被拒绝，await 会抛出一个错误，这个错误可以被 try...catch 捕获。


#### async 和 await 的优势
+ 代码更简洁：相比于使用 Promise 的链式调用，async 和 await 可以使异步代码看起来像同步代码，增强代码的可读性。
+ 错误处理更容易：可以使用标准的 try...catch 语法来捕获异步操作中的错误，而不需要单独的错误处理函数。
+ 调试更方便：由于代码看起来更像同步代码，调试器可以更容易地逐行调试异步代码。

## 21 webpack的打包流程

Webpack 是一个流行的模块打包工具，用于将多个 JavaScript 模块和资源打包成一个或多个优化的文件，以提高网页的加载速度和性能。Webpack 的打包流程包括几个关键的步骤：

#### 1. 初始化

Webpack 通过读取配置文件（如 `webpack.config.js`）来初始化。配置文件中定义了入口文件、输出文件、加载器（loader）、插件（plugin）等信息。

```javascript
module.exports = {
  entry: './src/index.js',
  output: {
    filename: 'bundle.js',
    path: __dirname + '/dist'
  },
  module: {
    rules: [
      {
        test: /\.js$/,
        exclude: /node_modules/,
        use: 'babel-loader'
      }
    ]
  },
  plugins: [
    new HtmlWebpackPlugin({
      template: './src/index.html'
    })
  ]
};
```

#### 2. 构建依赖图

Webpack 从入口文件开始，递归地解析模块的依赖关系，构建一个依赖图（Dependency Graph）。在这个过程中，Webpack 会处理每个模块的导入和导出，解析模块依赖。

#### 3. 模块转换

在构建依赖图的过程中，Webpack 使用配置中的加载器（loader）来转换不同类型的文件。例如，`babel-loader` 会将 ES6 代码转换为 ES5，`css-loader` 会处理 CSS 文件，`file-loader` 会处理图像文件等。

```javascript
module: {
  rules: [
    {
      test: /\.js$/,
      exclude: /node_modules/,
      use: 'babel-loader'
    },
    {
      test: /\.css$/,
      use: ['style-loader', 'css-loader']
    },
    {
      test: /\.(png|svg|jpg|gif)$/,
      use: ['file-loader']
    }
  ]
}
```

#### 4. 模块打包

Webpack 根据依赖图将所有模块打包成一个或多个文件。默认情况下，Webpack 会生成一个单独的 JavaScript 文件（通常命名为 `bundle.js`），其中包含所有模块的代码。通过代码拆分和懒加载，Webpack 也可以将代码分割成多个文件，以优化性能。

#### 5. 插件处理

Webpack 在打包过程中使用插件来完成各种任务，如优化代码、注入环境变量、生成 HTML 文件等。插件是扩展 Webpack 功能的强大工具，通过插件可以实现复杂的构建流程和优化策略。

```javascript
plugins: [
  new HtmlWebpackPlugin({
    template: './src/index.html'
  }),
  new DefinePlugin({
    'process.env.NODE_ENV': JSON.stringify('production')
  }),
  new MiniCssExtractPlugin({
    filename: '[name].[contenthash].css'
  })
]
```

#### 6. 输出文件

Webpack 将打包好的文件输出到配置指定的目录。输出文件包括 JavaScript 文件、CSS 文件、图片等资源文件。

```javascript
output: {
  filename: 'bundle.js',
  path: __dirname + '/dist'
}
```

#### 7. 热更新和开发服务器

在开发过程中，Webpack 提供了开发服务器（Webpack Dev Server），支持热更新（Hot Module Replacement, HMR），使开发更加高效。开发服务器会监听文件变化，并自动刷新浏览器或更新模块，无需手动刷新页面。

```javascript
devServer: {
  contentBase: './dist',
  hot: true
}
```

#### 总结

Webpack 的打包流程大致如下：

1. **初始化**：读取配置文件，创建 Compiler 实例。
2. **构建依赖图**：从入口文件开始，递归解析模块依赖，构建依赖图。
3. **模块转换**：使用加载器将不同类型的文件转换为 JavaScript 模块。
4. **模块打包**：根据依赖图将所有模块打包成一个或多个文件。
5. **插件处理**：使用插件执行各种任务，如优化、注入、生成文件等。
6. **输出文件**：将打包好的文件输出到指定目录。
7. **热更新和开发服务器**：在开发过程中使用开发服务器和热更新功能，提高开发效率。

通过这些步骤，Webpack 可以将复杂的项目结构和多种资源类型打包成高效的文件，优化网页的加载性能和用户体验。

## 22 实现树的深度优先和广度优先
```js
const treeData = {
  value: 'a',
  children: [{
    value: 'b',
    children: [{
      value: 'd',
      children: []
    }, {
      value: 'e',
      children: []
    }]
  }, {
    value: 'c',
    children: [{
      value: 'f',
      children: []
    }, {
      value: 'g',
      children: []
    }]
  }]
}

// 深度优先算法
const deepFirstSearch = (tree, result = []) => {
  if(tree) {
    result.push(tree.value);
    const children = tree.children;
    for(let i = 0; i < children.length; i++) {
      deepFirstSearch(children[i], result);
    }
  }
  return result;
};

// 栈 - stack 先进后出
const deepFirstSearch1 = (tree, result = []) => {
  if(tree) {
    const stack = [tree];
    while(stack.length != 0) {
      const item = stack.pop(); // 取出队列最后一项
      result.push(item.value);
      const children = item.children;
      for(let i = children.length - 1; i >= 0 ; i--) {
        stack.push(children[i]); // 将子节点从右到左推入栈中
      }
    }
  }
  return result;
};

// 广度优先算法 - 队列 先进先出
const breadthFirstSearch = (tree, result = []) => {
  if(tree) {
    const queue = [tree];
    while(queue.length != 0) {
      const item = queue.shift(); // 从队列头部取出节点
      result.push(item.value);
      const children = item.children;
      for(let i = 0; i < children.length; i++) {
        queue.push(children[i]); // // 将子节点依次推入队列
      }
    }
  }
  return result;
};
console.log('深度',deepFirstSearch(treeData));
console.log('深度1',deepFirstSearch1(treeData));
console.log('广度',breadthFirstSearch(treeData));

```

## 23 什么是CSRF,如何避免CSRF
> CSRF（Cross-Site Request Forgery，跨站请求伪造）是一种网络攻击，它利用受害者在受信任网站上的身份，发送伪造的请求，通常是执行一些未授权的操作，例如转账、修改账户信息等。攻击者通过诱导用户访问特制的网页或点击恶意链接，向受信任网站发送未经用户同意的请求。

#### 1. CSRF工作原理

1. **用户登录受信任网站**：用户在浏览器中登录某个受信任的网站，并且该网站在用户的浏览器中设置了一个会话 cookie。
2. **用户访问恶意网站**：攻击者诱导用户访问一个恶意网站，或者用户点击了恶意邮件中的链接。
3. **恶意网站发送请求**：恶意网站构造一个请求，该请求利用用户在受信任网站的会话 cookie，发送伪造的请求到受信任的网站。
4. **受信任网站处理请求**：受信任的网站在不知道请求是伪造的情况下，执行了请求中的操作。

#### 2. 如何避免CSRF攻击

  1. **使用 `CSRF Token`**
  + 在每次用户请求页面时，服务器生成一个唯一的 CSRF Token，并将其嵌入到页面的表单或请求中。
  + 服务器在接收到请求时，验证请求中的 CSRF Token 是否有效。
  + 如果 Token 验证失败，则拒绝请求。

  2. **使用 `SameSite Cookie` 属性**
  + 将会话 cookie 设置为 SameSite 属性，防止浏览器在跨站请求中发送 cookie。
  + SameSite 有三个值：Strict、Lax 和 None。Strict 是最严格的，仅在同一站点请求时发送 cookie。

  3. **双重提交 `Cookie`**
  + 将 CSRF Token 存储在会话 cookie 中，并在请求时同时在表单数据或请求头中发送该 Token。
  + 服务器验证两个 Token 是否匹配。

## 24 JS 原型和原型链

#### 1. 谈谈你对 JS 原型和原型链的理解？
> JS 原型是指为其它对象提供共享属性访问的对象。在创建对象时，每个对象都包含一个隐式引用指向它的原型对象或者 null。原型也是对象，因此它也有自己的原型。这样构成一个原型链。

#### 2. 原型链有什么作用？
> 在访问一个对象的属性时，实际上是在查询原型链。这个对象是原型链的第一个元素，先检查它是否包含属性名，如果包含则返回属性值，否则检查原型链上的第二个元素，以此类推。

#### 3. 那如何实现原型继承呢？

有两种方式。
+ 一种是通过 Object.create 或者 Object.setPrototypeOf 显式继承另一个对象，将它设置为原型。
+ 另一种是通过 constructor 构造函数，在使用 new 关键字实例化时，会自动继承 constructor 的 prototype 对象，作为实例的原型。

#### 4. 实现new

在调用 new 的过程中会发生以上四件事情：
1. 首先创建了一个新的空对象
2. 设置原型，将对象的原型设置为函数的 prototype 对象。
3. 让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）
4. 判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。

```js
function objectFactory() {
  let newObject = null;
  let constructor = Array.prototype.shift.call(arguments);
  let result = null;
  // 判断参数是否是一个函数
  if (typeof constructor !== "function") {
    console.error("type error");
    return;
  }
  // 新建一个空对象，对象的原型为构造函数的 prototype 对象
  newObject = Object.create(constructor.prototype);
  // 将 this 指向新建对象，并执行函数
  result = constructor.apply(newObject, arguments);
  // 判断返回对象
  let flag = result && (typeof result === "object" || typeof result === "function");
  // 判断返回结果
  return flag ? result : newObject;
}
// 使用方法
objectFactory(`构造函数`, `初始化参数`);
```

## 25 vite的打包流程   vite与webpack的区别
#### Vite 的打包流程

1. **开发服务器启动**：
   - 在开发模式下，Vite 使用原生 ES 模块加载进行模块解析和热重载。它启动一个开发服务器，实时响应文件的变化。
   - Vite 不进行预打包，而是直接使用浏览器的能力加载模块，并进行按需编译。

2. **模块加载与转换**：
   - 当一个模块被请求时，Vite 会在服务端快速转换和处理这个模块，包括处理现代 JavaScript 特性（如 JSX、TypeScript）和各种资源（如 CSS、图像）。
   - 通过 ESBuild 和 Rollup 的结合，Vite 可以快速进行代码转换和模块解析。

3. **热模块替换（HMR）**：
   - Vite 实现了高效的 HMR，使用 WebSocket 通信，保证代码变更可以即时在浏览器中反映，无需重新加载整个页面。
   - HMR 机制允许在开发过程中保留应用的状态，而不需要重新加载应用。

4. **生产构建**：
   - 在生产模式下，Vite 使用 Rollup 进行最终的打包，将所有模块和资源进行优化和打包。
   - Rollup 负责树摇（tree-shaking）和代码分割（code-splitting），确保输出的代码体积尽可能小。

5. **优化和输出**：
   - Vite 会对生产环境中的代码进行优化，包括压缩 JavaScript 和 CSS，内联小资源，删除未使用的代码等。
   - 最终生成的文件会输出到指定的目录（通常是 `dist` 目录），可以直接部署到生产环境。

#### Vite 与 Webpack 的区别

1. **开发体验**：
   - **Vite**：利用浏览器的原生 ES 模块支持，启动速度快，代码变更反应迅速，支持即时热模块替换（HMR）。
   - **Webpack**：需要进行模块预打包，启动速度较慢，热更新速度也不如 Vite 快。

2. **模块处理方式**：
   - **Vite**：在开发模式下，模块以原生 ES 模块的形式加载和处理，按需进行转换。
   - **Webpack**：所有模块在构建时被打包成一个或多个文件，开发时需要依赖预打包。

3. **打包工具**：
   - **Vite**：开发模式下使用 ESBuild，生产模式下使用 Rollup，结合了两者的优点，提供了高效的模块处理和优化。
   - **Webpack**：自身即是一个打包工具，提供完整的打包和优化功能，依赖插件和加载器来处理各种文件类型。

4. **配置复杂度**：
   - **Vite**：默认配置简洁，开箱即用，适合快速开发和简单配置。
   - **Webpack**：配置相对复杂，需要更多的配置文件和插件，适合复杂的项目需求。

5. **性能优化**：
   - **Vite**：利用 ESBuild 的高性能编译和 Rollup 的强大优化能力，开发和生产模式下都表现出色。
   - **Webpack**：依赖大量插件进行优化，可能需要手动配置和调整才能达到最佳性能。

#### 示例代码

###### Vite 配置示例（vite.config.js）

```javascript
import { defineConfig } from 'vite';
import vue from '@vitejs/plugin-vue';

export default defineConfig({
  plugins: [vue()],
  build: {
    outDir: 'dist',
    rollupOptions: {
      // Rollup-specific options
    }
  },
  server: {
    port: 3000,
    open: true,
    hmr: {
      overlay: true
    }
  }
});
```

###### Webpack 配置示例（webpack.config.js）

```javascript
const path = require('path');
const HtmlWebpackPlugin = require('html-webpack-plugin');
const { VueLoaderPlugin } = require('vue-loader');

module.exports = {
  entry: './src/main.js',
  output: {
    filename: 'bundle.js',
    path: path.resolve(__dirname, 'dist')
  },
  module: {
    rules: [
      {
        test: /\.vue$/,
        loader: 'vue-loader'
      },
      {
        test: /\.js$/,
        loader: 'babel-loader',
        exclude: /node_modules/
      },
      {
        test: /\.css$/,
        use: ['style-loader', 'css-loader']
      }
    ]
  },
  plugins: [
    new HtmlWebpackPlugin({
      template: './public/index.html'
    }),
    new VueLoaderPlugin()
  ],
  devServer: {
    contentBase: './dist',
    hot: true,
    open: true,
    port: 3000
  }
};
```

#### 总结

Vite 和 Webpack 都是强大的构建工具，但它们在设计理念、开发体验、配置复杂度和性能优化上有着显著的区别。Vite 更适合现代前端开发，尤其是在开发速度和体验方面有明显优势，而 Webpack 则更加成熟，适用于复杂项目的构建需求。根据项目需求选择合适的工具，可以大大提升开发效率和项目性能。

## 26 实现插入排序


## 27 实现add方法完成两个大数相加

以下是一个使用 JavaScript 实现大数相加的 `add` 方法：

```javascript
function add(num1, num2) {
    // 确保 num1 和 num2 是字符串
    num1 = num1.toString();
    num2 = num2.toString();
    
    // 确保 num1 是更长的那个，如果不是则交换
    if (num1.length < num2.length) {
        [num1, num2] = [num2, num1];
    }
    
    // 反转字符串以便从最低位开始相加
    num1 = num1.split('').reverse().join('');
    num2 = num2.split('').reverse().join('');
    
    // 结果数组和进位变量
    let result = [];
    let carry = 0;
    
    // 遍历所有位
    for (let i = 0; i < num1.length; i++) {
        let digit1 = parseInt(num1[i]);
        let digit2 = i < num2.length ? parseInt(num2[i]) : 0;
        
        // 当前位的总和和进位
        let total = digit1 + digit2 + carry;
        
        // 计算当前位的值和新的进位
        let currentDigit = total % 10;
        carry = Math.floor(total / 10);
        
        // 将当前位的值添加到结果中
        result.push(currentDigit);
    }
    
    // 如果还有剩余的进位，将其添加到结果中
    if (carry > 0) {
        result.push(carry);
    }
    
    // 反转结果并转换为字符串
    return result.reverse().join('');
}

// 示例用法
console.log(add("12345678901234567890", "98765432109876543210"));  // "111111111011111111100"
```

#### 解释

1. **字符串转换和交换**:
   - 首先确保 `num1` 和 `num2` 是字符串。
   - 如果 `num1` 比 `num2` 短，交换它们，这样我们总是从较长的字符串开始。

2. **反转字符串**:
   - 将字符串反转，以便从最低位开始相加。

3. **初始化结果和进位**:
   - 使用数组 `result` 来存储每一位的结果。
   - 使用 `carry` 来处理进位。

4. **逐位相加**:
   - 遍历 `num1` 的每一位，取出相应的 `num2` 的位，如果存在。
   - 计算当前位的总和 `total` 和新的进位 `carry`。
   - 将当前位的值添加到结果数组中。

5. **处理剩余的进位**:
   - 如果最后还有进位，将其添加到结果中。

6. **结果转换**:
   - 反转结果数组并转换为字符串。

## 28 如何获取对象非原型链上的属性

## 29 TSL/SSL的工作原理

## 30 node中的事件循环

## 31 进程和线程的区别 浏览器中如何通信

## 32 判断对称二叉树

## 33 service worker

## 34 输出字符串全排列

## 35 最长回文子串

## 36 hooks为什么只能写在顶层，不写顶层会报错吗

## 37 http 301 302 307的区别

## 38 pinia的原理和vuex的区别

## 39 vite原理

## 40 esm和commonjs区别

## 41 less-loader 底层原理

## 42 发布订阅 

## 43 观察者模式

