---
layout: doc
---

## 2024 年 8 月 1 日
> 今天晚上7:00参加抖音用户web前端开发专业二面：
问题：
自我介绍
1.你有什么优势
2.对一些问题如何思考
在交警现场出现问题，会有电脑再打开系统第二天早上出现内存泄漏问题，而且是偶发的问题。
分析问题定位出现问题的情况：
（1）先排查发布版本中新增代码是否存在，对一些图层定时器为清空导致内存增长的问题
（2）咨询是否和电脑配置和浏览器版本相关，以及使用情况？配置差不多，浏览器版本也不是很老 90+，安装相同版本浏览器，使用memory分析内存情况
排除版本问题
（3）减少内存占用情况，分析内存使用两个主要问题：`windows.open`打开窗口没有增加noopener公用主内存增加内存使用，系统中在地图中路口信号状态
图片会占用内存，改写使用方式

3.动态感知系统做了啥
该系统是为深圳地铁客运和行车部门开发的客流动态感知平台，在这个平台可以实时展示地铁客流运行状况并依据地铁刷卡数据实时进行短时客流预测，
对客流状况预警，方便提前感知处理大客流状况， 同时可以对重大活动新线开通突发事件做客流预测，便于提前预言客流状况做应对处理。
通过地铁线网图展示客流状况，现有的不能满足需求，需要区段并双向运行，还有大量交互和窗处理，只能自己开发，技术选型时有svg、canvas、leaflete等。
要求UI按线路级运行方向绘制svg，并依据静态区段站点id匹配 使用nodejs将数据处理为一份json数据，包括每条线路的方向区段先 path 站点名称 站点等数据
然后根据数据动态驱动绘制。

4.移动端如何适配 （主流的移动端适配方案）
（1）flexible 适配方案 通过postcss-px2rem修改htmlfontsize 并同步修改 mate viewport 
`scale = 1 / window.devicePixelRatio;`
`width=devide-width, inital-scale=scale, maxium-scale=scale,minimum-scale=scale, user-scalable=no `

（2） （视口单位）vw 方案 postcss-px-to-viewport
写代码时，我们只需要根据UI给的设计图写px单位即可
对于margin和padding对布局的影响尽量通过calc()避免
会存在1px的问题 
vant 底部安全区问题：
部分手机有底部安全区域，该区域会有一条横线遮挡，遮挡部分会影响操作，因此页面的底部需要剔除该区域。工程代码已经预埋了样式代码解决该问题。
```less
// src/global/style/main.less 文件中包含以下代码
// 在现代 CSS 中，env() 是一个函数，用于访问环境变量。constant() 是旧版本的语法，主要用于旧的 iOS 设备。

// 这段代码的作用是在支持安全区域变量的环境中，给 body 元素设置底部填充（padding-bottom），确保内容不会被设备的物理边缘遮挡。
@supports (bottom: env(safe-area-inset-bottom)) {
  body {
    --fix-bottom: constant(safe-area-inset-bottom);
    padding-bottom: constant(safe-area-inset-bottom);
    --fix-bottom: env(safe-area-inset-bottom);
    padding-bottom: env(safe-area-inset-bottom);
  }
}
```
需要注意以下内容：

页面布局为底部tab和页面内容，tab切换页面时，建议页面容器高度百分百，用flex垂直布局，让内容部分的flex: 1，底部tab的高度固定，代码示例如下：
```vue
<template>
  <div class="layout-wrap">
    <div class="layout-content">
      <router-view />
    </div>
    <TabNav />
  </div>
</template>

<style lang="less" scoped>
.layout-wrap {
  height: 100%;
  display: flex;
  flex-direction: column;
}
.layout-content {
  flex: 1;
  width: 100%;
  height: 0;
}
</style>
```
在类似提交表单页面中，经常有底部（新建、提交）之类的按钮，如果底部的内容定位用position: fixed的话，则bottom值需要加上css样式变量
```less
.bottom-button {
  position: fixed;
  bottom: var(--fix-bottom);
}
```
（3） @media 媒体查询 根据屏幕宽度写不同的css
（4）百分比

5.小组如何管理
（1）分配开发任务，跟进开发进度
（2）协助解决问题，提供解决方案
（3）组织codeReview, 提高开发共识和代码质量
（4）协助沟通拉通资源
6.webpack优化方式 
构建产物优化：
（1）tree shanking
（2）chunk split
（3）gzip [css js img]
（4）懒加载和动态导入
（5）优化 mode 和 devtool
（6）单独打包第三方库


构建过程优化：
（1）持久缓存
（2）多线程
（3）对第三方插件避免重复打包 dll
（4）优化模块解析，配置高效的后缀检索，书写写全减少检索时间
（6）开启比如 babel loader 缓存
7.threejs webgl有深入的理解吗？
8.lcp优化有什么影响吗？
算法：
1.千分位
2.计算器操作插件类

```js
// class Calculator {
//     register() {}
//     input() {}
//     press() {}
//     equal() {}
// }

// class Plus {
    
// }

// // 初始化计算器
// const calculator = new Calculator()

// // 注册加号插件
// calculator.register(new Plus())

// calculator.input(2)
// calculator.press('plus')
// calculator.input(3)

// const result = calculator.equal()

// console.log(result) // 5

// 实现思路 Calculator 负责调度 插件 提供的算法结算结果
class Calculator {
    constructor() {
        this.operations = {};
        this.currentValue = 0;
        this.currentOperation = null;
    }

    register(plugin) {
        this.operations[plugin.name] = plugin.operation;
    }

    input(number) {
        if (this.currentOperation === null) {
            this.currentValue = number;
        } else {
            this.currentValue = this.operations[this.currentOperation](this.currentValue, number);
            this.currentOperation = null;
        }
    }

    press(operation) {
        if (this.operations[operation]) {
            this.currentOperation = operation;
        } else {
            throw new Error(`Operation "${operation}" not registered.`);
        }
    }

    equal() {
        const result = this.currentValue;
        this.currentValue = 0;
        this.currentOperation = null;
        return result;
    }

    reset() {
        this.currentValue = 0;
        this.currentOperation = null;
    }
}

class Plus {
    get name() {
        return 'plus';
    }

    get operation() {
        return (a, b) => a + b;
    }
}

// 初始化计算器
const calculator = new Calculator();

// 注册加号插件
calculator.register(new Plus());

calculator.input(2);
calculator.press('plus');
calculator.input(3);

const result = calculator.equal();

console.log(result); // 输出: 5
```

反问：
1.AI 快速发展在内部 对开发利用AI提效都有哪些实践。
答： 
处于对内部资产保护，内部自己部署自己的AI模型，使用大方面包括但不限于：
（1）vscode插件代码提示工具
（2）AI进行代码的CodeReview
（3）基于低代码平台，训练基于物料生产页面
（4）重复的数据处理和逻辑 比如生成视屏标题
（5）根据历史数据训练，并分析为什么今天的pwa增加等
（6）深入开发工作的日常，到处都充斥着AI的身影，提升工作效率




系统性能优化，首屏优化做了什么：
1. 开启静态资源缓存， keepalive， 静态资源单独域名
2. 小： gzip压缩， 动态路由，动态组件，懒加载， 图片压缩
代码分割:
(1)相关库单独打包
(2)单个文件体积大拆分
去掉无用的代码:
(1).rollup-plugin-visualizer分析打包后文件，对于全量引用改为部分引用
(2).tree shanking

3. 资源 cdn ssr  减少http请求
http2.0:
(1).采用二进制格式传输数据, 1.1是文本格式
(2).对消息头采用Hpack进行压缩传输，能够节省消息头占用的网络流量，1.1每次请求，都会携带大量冗余的头信息，浪费了很多宽带资源
(3).异步连接多路复用
(4).Server Push，服务器端能够更快的把资源推送到客户端
(5).保持与HTTP 1.1语义的向后兼容性也是该版本的一个关键

4. 增加过渡动画
Transition, loading, 首屏骨架ssr 代码注入


地铁：
svg线网图：
需求背景： 要对地铁线路站点双向断面客流展示，目前的第三方不能满足需求。
通过UI提供的svg文件和基础的站点断面数据，处理为json数据。
使用时 根据数据动态渲染

postcss-pxtorem :
首先定义baseSize: 通过屏幕高度与设计稿高度计算font-size, 并将比例系数存入系统配置
按设计稿尺寸编写，有些注意的内联样式的style尺寸样式需要乘以系数
有特殊尺寸要求，通过@media修改页面布局
监听resize 重新挂载


信控：
内存溢出优化：
问题描述： 系统在生产环境部分电脑会发生第二天早上发现电脑 out of memory内存溢出。
分析问题： 浏览器自带的memory 和任务管理器分析内存泄漏的原因
普遍问题排查：未及时清除的定时器，图层以及图层注册事件的销毁。
1. 路口监视通过window.open打开每个路口的监视页面由于没有添加noopener参数，
noopener是否打开新的浏览器上下文就不共用当前上下文，也因此不能通过window.opener访问原窗口
2. 页面中实时监视路口的运行模式弹窗使用图片 当数据变化通过svg绘制为目标样式 并通过canvas new Image添加到地图中
原有的图片没哟销毁逻辑，导致新的图片不断生成，内存增大。
分析实现逻辑不同在于背景样式，通过对各样式的背景提前处理为图片，共48种，提升了渲染效率也避免了内存增大问题


h5:
1、单独配置一份打包vue组件的配置，打出编译后的组件，此时会得到有渲染函数的组件 js+对应的css;
2、通过动态import加载编译后的js文件，得到component，再传入给createSSRApp + renderT
oString 得到html字符串，同时也从打包后的css文件读取css字符串，有了css + html 字符串
就是完整的骨架屏代码;
3、最后通过vite插件vite-plugin-ejs 把骨架屏代码注入到html文件里。

vite build.lib 打包库模式 可以将spc组件打包编译为带有渲染函数的js和css文件
lib:{
entry: '待打包的文件路径'，
name: '',
fileName: '',
formats: ['es']
}
如果 package.json 不包含 "type": "module"，Vite 会生成不同的文件后缀名以兼容 Node.js。.js 会变为 .mjs 而 .cjs 会变为 .js
ejs 嵌入式javaScript模版引擎 <%- code %>




